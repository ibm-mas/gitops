---

# Permit outbound communication by the Job pods
# (Needed to communicate with the K8S HTTP API and AWS SM)
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  generateName: postsync-delete-config-crs-sa-np
  namespace: "mas-{{ .Values.instance.id }}-core"
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  podSelector:
    matchLabels:
      app: "postsync-delete-config-crs-job"
  egress:
    - {}
  policyTypes:
    - Egress

---
apiVersion: batch/v1
kind: Job
metadata:
  generateName: "postsync-delete-config-crs-job"
  namespace: "mas-{{ .Values.instance.id }}-core"
  annotations:
    argocd.argoproj.io/hook: PostSync
    # argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  template:
    metadata:
      labels:
        app: "postsync-delete-config-crs-job"
    spec:
      containers:
        - name: run
          # TODO: use a dedicated image with a smaller footprint for this sort of thing?
          # Just using cli for now since it has all the deps we need to talk with AWS SM
          image: quay.io/ibmmas/cli:7.10.0-pre.gitops
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 200m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 64Mi
          env:
            - name: INSTANCE_ID
              value: "{{ .Values.instance.id }}"

            - name: MONGO_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "mongo" | empty) }}"

            - name: JDBC_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "jdbc" | empty) }}"

            - name: SLS_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "sls" | empty) }}"

            - name: BAS_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "bas" | empty) }}"

            - name: KAFKA_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "kafka" | empty) }}"

            - name: IDP_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "idp" | empty) }}"

            - name: SMTP_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "smtp" | empty) }}"

            - name: OBJECTSTORAGE_ABSENT
              value: "{{ or (index .Values "system-configs" | empty) (index .Values "system-configs" "objectstorage" | empty) }}"


          volumeMounts: []
          command:
            - /bin/sh
            - -c
            - |

              set -e

              function delete_oc_resource(){
                RESOURCE=$1
                NAMESPACE=$2
                echo
                echo "------------------------------------------------------------------"
                echo "Check if resource $RESOURCE is present in namespace $NAMESPACE "

                # don't want a non-zero rc from oc delete to cause the job to fail
                # so, temporarily set +e
                set +e
                RESOURCE_NAME=$(oc get $RESOURCE -n $NAMESPACE -o=jsonpath="{.metadata.name}")
                set -e
                if [[ -z "${RESOURCE_NAME}" ]]; then
                  echo "$RESOURCE not found, skipping"
                  return 0
                fi

                echo "oc delete resource $RESOURCE in namespace $NAMESPACE "

                # don't want a non-zero rc from oc delete to cause the job to fail (since we then want to try patching out the finalizers)
                # so, temporarily set +e
                set +e
                oc delete $RESOURCE -n $NAMESPACE --timeout=300s --wait=true
                return_code=$?
                set -e

                if [ $return_code -ne 0 ]; then
                  echo "oc delete timed out after 300s, forcing delete by removing finalizers"
                  echo "oc patch $RESOURCE -n $NAMESPACE"

                  # NOTE: set -e, so job will exit if this fails (which is what we want)
                  oc patch $RESOURCE -n $NAMESPACE --type="json" -p '[{"op": "remove", "path":"/metadata/finalizers"}]' 2>/dev/null
                fi

                echo "Verify that resource $RESOURCE is now absent in namespace $NAMESPACE "
                # don't want a non-zero rc from oc delete to cause the job to fail
                # so, temporarily set +e
                set +e
                RESOURCE_NAME=$(oc get $RESOURCE -n $NAMESPACE -o=jsonpath="{.metadata.name}")
                set -e
                if [[ -n "${RESOURCE_NAME}" ]]; then
                  echo "$RESOURCE still present, failing job"
                  exit 1
                fi

                echo "... verified"
                return 0
                
              }

              echo "JDBC_ABSENT .................. ${JDBC_ABSENT}"
              echo "KAFKA_ABSENT ................. ${KAFKA_ABSENT}"
              echo "IDP_ABSENT ................... ${IDP_ABSENT}"
              echo "SMTP_ABSENT .................. ${SMTP_ABSENT}"
              echo "OBJECTSTORAGE_ABSENT ......... ${OBJECTSTORAGE_ABSENT}"
              echo "SLS_ABSENT ................... ${SLS_ABSENT}"
              echo "MONGO_ABSENT ................. ${MONGO_ABSENT}"
              echo "BAS_ABSENT ................... ${BAS_ABSENT}"

              if [[ "${JDBC_ABSENT}" == "true" ]]; then
                delete_oc_resource "jdbccfgs.config.mas.ibm.com/system.ibm-mas-jdbc-config" "mas-${INSTANCE_ID}-core"
              fi

              if [[ "${KAFKA_ABSENT}" == "true" ]]; then
                delete_oc_resource "kafkacfgs.config.mas.ibm.com/${INSTANCE_ID}-kafka-system" "mas-${INSTANCE_ID}-core"
              fi

              if [[ "${IDP_ABSENT}" == "true" ]]; then
                delete_oc_resource "idpcfgs.config.mas.ibm.com/${INSTANCE_ID}-ldap-default-system" "mas-${INSTANCE_ID}-core"
              fi

              if [[ "${SMTP_ABSENT}" == "true" ]]; then
                delete_oc_resource "smtpcfgs.config.mas.ibm.com/${INSTANCE_ID}-smtp-system" "mas-${INSTANCE_ID}-core"
              fi

              if [[ "${OBJECTSTORAGE_ABSENT}" == "true" ]]; then
                delete_oc_resource "objectstoragecfgs.config.mas.ibm.com/${INSTANCE_ID}-objectstorage-system" "mas-${INSTANCE_ID}-core"
              fi

              if [[ "${SLS_ABSENT}" == "true" ]]; then
                delete_oc_resource "slscfgs.config.mas.ibm.com/${INSTANCE_ID}-sls-system" "mas-${INSTANCE_ID}-core"
              fi

              if [[ "${MONGO_ABSENT}" == "true" ]]; then
                delete_oc_resource "mongocfgs.config.mas.ibm.com/${INSTANCE_ID}-mongo-system" "mas-${INSTANCE_ID}-core"
              fi

              if [[ "${BAS_ABSENT}" == "true" ]]; then
                delete_oc_resource "bascfgs.config.mas.ibm.com/${INSTANCE_ID}-bas-system" "mas-${INSTANCE_ID}-core"
              fi

      restartPolicy: Never

      # OK to piggyback on ibm-mas-coreapi role here? This has all the access we need (delete config.mas.ibm.com)
      # If not, we'll need to setup a service account in this chart (note: >1 cleanup job might be running at once, so the SA name
      # will have to made unique, but such a way that we can know what it is so we can reference it here in the job)
      serviceAccountName: "ibm-mas-coreapi"
      volumes: []
  backoffLimit: 4
