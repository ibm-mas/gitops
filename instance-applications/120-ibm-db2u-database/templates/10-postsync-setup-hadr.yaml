{{ if and (default .Values.replica_db false) (contains "sdb" .Values.db2_instance_name) }}
---
kind: ServiceAccount
apiVersion: v1
metadata:
  name: "postsync-hadr-sa-{{ .Values.db2_instance_name }}"
  namespace: "{{ .Values.db2_namespace }}"
  annotations:
    argocd.argoproj.io/sync-wave: "128"
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}


---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: "db2-database-postsync-hadr-sa-role-{{ .Values.db2_instance_name }}"
  namespace: "{{ .Values.db2_namespace }}"
  annotations:
    argocd.argoproj.io/sync-wave: "128"
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
- apiGroups:
    - ""
  resources:
    - pods
  verbs:
    - get
    - list
    - watch
- apiGroups:
    - ""
  resources:
    - pods/exec
  verbs:
    - get
    - list
    - create
- apiGroups:
    - ""
  resources:
    - services
  verbs:
    - "get"
- apiGroups:
    - db2u.databases.ibm.com
  resources:
    - db2uinstances
  verbs:
    - "get"

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: "db2-database-postsync-hadr-sa-rb-{{ .Values.db2_instance_name }}"
  namespace: "{{ .Values.db2_namespace }}"
  annotations:
    argocd.argoproj.io/sync-wave: "128"
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: "postsync-hadr-sa-{{ .Values.db2_instance_name }}"
    namespace: "{{ .Values.db2_namespace }}"
roleRef:
  kind: Role
  name: "db2-database-postsync-hadr-sa-role-{{ .Values.db2_instance_name }}"
  apiGroup: rbac.authorization.k8s.io

---
apiVersion: batch/v1
kind: Job
metadata:
  # Suffix the Job name with a hash of all chart values
  # This is to ensure that ArgoCD will delete and recreate the job if (and only if) anything changes in the DB2 config
  name: postsync-setup-hadr-{{ .Values.db2_instance_name }}-v1-{{ omit .Values "junitreporter" | toYaml | adler32sum }}
  namespace: "{{ .Values.db2_namespace }}"
  annotations:
    argocd.argoproj.io/sync-wave: "130"
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  template:
{{- if .Values.custom_labels }}
    metadata:
      labels:
{{ .Values.custom_labels | toYaml | indent 8 }}
{{- end }}
    spec:
      restartPolicy: Never
      serviceAccountName: "postsync-hadr-sa-{{ .Values.db2_instance_name }}"
      containers:
        - name: run
          image: quay.io/ibmmas/cli:latest
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 200m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 64Mi
          env:
            - name: MAS_INSTANCE_ID
              value: {{ .Values.instance_id }}
            - name: MAS_APP_ID
              value: {{ .Values.mas_application_id}}
            - name: DB2_NAMESPACE
              value: "{{ .Values.db2_namespace }}"
            - name: DB2_INSTANCE_NAME
              value: "{{ .Values.db2_instance_name }}"
            - name: DB2_DBNAME
              value: "{{ .Values.db2_dbname }}"
          command:
            - /bin/sh
            - -c
            - |

              set -e

              source /mascli/functions/gitops_utils

              function wait_for_resource {
                RES_TYPE="$1"
                RES_NAME="$2"
                RES_NS="$3"
                RETRIES=${4:-10}
                RETRY_DELAY_SECONDS=${5:-30}

                for (( c=1; c<="${RETRIES}"; c++ )); do

                  echo "... attempt ${c} of ${RETRIES}"

                  rc=0
                  oc get "${RES_TYPE}/${RES_NAME}" -n "${RES_NAMESPACE}" || rc=$?
                  if [[ "$rc" == "0" ]]; then
                    echo "...... success"
                    return 0
                  fi

                  if [[ "${c}" -lt "${RETRIES}" ]]; then
                    echo "...... failed (rc: ${rc}), retry in ${RETRY_DELAY_SECONDS}s"
                    sleep $RETRY_DELAY_SECONDS
                  fi
                done

                echo "...... failed, no attempts remain"
                return 1
              }


              # The Db2u operator is capable of automatically applying dbConfig, dbmConfig and registry configuration parameters specified on the Db2uInstance CR.
              # However, certain parameters (e.g. MIRRORLOGPATH)  may reference paths on the db2u pod (e.g. /mnt/backup/MIRRORLOGPATH) that do not exist until 
              # after the operator has already attemped to apply settings (which it will not subsequently reattempt if something went wrong).
              # To work around this, we manually re-invoke this process again by calling the '/db2u/scripts/apply-db2cfg-settings.sh --setting all' script on the db2 pod.

              # Moreover, the Db2u operator it does not give any indication on any CR if something went wrong while attempting to apply these settings (and no meaningful return code is provided by the apply-db2cfg-settings.sh script)
              # For this reason, we are forced to perform our own verification that the settings on the Db2uInstance CR align with those active in DB2 
              # This is done using the "mas-devops-db2-validate-config" command from the mas-devops library (see https://github.com/ibm-mas/python-devops)
              function db2apply {
                echo ""
                oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME}-db2u-0 -- su -lc '/db2u/scripts/apply-db2cfg-settings.sh --setting all | tee /tmp/apply-db2cfg-settings.log' db2inst1
                # no useful info in return code of this script
              }

              echo ""
              echo "================================================================================"
              echo "Waiting for pod c-${DB2_INSTANCE_NAME}-db2u-0 to be present before continuing (timeout 300s)"
              echo "================================================================================"
              wait_for_resource "pod" "c-${DB2_INSTANCE_NAME}-db2u-0" "${DB2_NAMESPACE}"

              echo ""
              echo "================================================================================"
              echo "Waiting for pod c-${DB2_INSTANCE_NAME}-db2u-0 to report Ready=True before continuing (timeout 300s)"
              echo "================================================================================"
              oc wait --for=condition=Ready pod/c-${DB2_INSTANCE_NAME}-db2u-0 --timeout 300s -n ${DB2_NAMESPACE}

              echo ""
              echo "================================================================================"
              echo "Waiting for service c-${DB2_INSTANCE_NAME}-db2u-engn-svc to be present before continuing (timeout 300s)"
              echo "================================================================================"
              wait_for_resource "svc" "c-${DB2_INSTANCE_NAME}-db2u-engn-svc" "${DB2_NAMESPACE}"

              echo ""
              echo "================================================================================"
              echo "Waiting for pod c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 to be present before continuing (timeout 300s)"
              echo "================================================================================"
              wait_for_resource "pod" "c-${DB2_INSTANCE_NAME:0:-4}-db2u-0" "${DB2_NAMESPACE}"

              echo ""
              echo "================================================================================"
              echo "Waiting for pod c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 to report Ready=True before continuing (timeout 300s)"
              echo "================================================================================"
              oc wait --for=condition=Ready pod/c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 --timeout 300s -n ${DB2_NAMESPACE}

              echo ""
              echo "================================================================================"
              echo "Waiting for service c-${DB2_INSTANCE_NAME:0:-4}-db2u-engn-svc to be present before continuing (timeout 300s)"
              echo "================================================================================"
              wait_for_resource "svc" "c-${DB2_INSTANCE_NAME:0:-4}-db2u-engn-svc" "${DB2_NAMESPACE}"

              echo ""
              echo "Creating /mnt/backup/MIRRORLOGPATH in c-${DB2_INSTANCE_NAME}-db2u-0"
              echo "--------------------------------------------------------------------------------"
              oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME}-db2u-0  -- su -lc "mkdir -p /mnt/backup/MIRRORLOGPATH" db2inst1 || exit $?

              echo ""
              echo "================================================================================"
              echo "Calling apply-db2cfg-settings.sh file on c-${DB2_INSTANCE_NAME}-db2u-0"
              echo "================================================================================"
              db2apply || exit $?

              # Copy the backup from primary to standby
              echo ""
              echo "Taking backup on ${DB2_NAMESPACE}/c-${DB2_INSTANCE_NAME:0:-4}-db2u-0"
              echo "--------------------------------------------------------------------------------"
              oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 -- su -lc "db2 backup db ${DB2_DBNAME} on all dbpartitionnums online to /mnt/backup | tee /tmp/dbbackup.log" db2inst1 || exit $?

              echo ""
              timestamp=`oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 -- su -lc "cat /tmp/dbbackup.log | grep 'timestamp' | rev | cut -d ' ' -f1 | rev" db2inst1`
              echo "Timestamp of backup is ${timestamp}"
              backup_filename=`oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 -- su -lc "ls /mnt/backup | grep ${timestamp}" db2inst1`
              echo "Backup filename is ${backup_filename}"

              echo ""
              echo "Copying backup /mnt/backup/${backup_filename} from ${DB2_NAMESPACE}/c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 to ${DB2_NAMESPACE}/c-${DB2_INSTANCE_NAME}-db2u-0 "
              oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 -- su -lc "cp /mnt/backup/${backup_filename} /tmp; chmod 777 /tmp/${backup_filename}" db2inst1 || exit $?
              oc cp ${DB2_NAMESPACE}/c-${DB2_INSTANCE_NAME:0:-4}-db2u-0:/tmp/${backup_filename} /tmp/${backup_filename}
              oc cp /tmp/${backup_filename} ${DB2_NAMESPACE}/c-${DB2_INSTANCE_NAME}-db2u-0:/tmp/${backup_filename}

              echo ""
              echo "Copying keystore from primary to standby"
              oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 -- su -lc "mkdir /tmp/keystore; cp /mnt/blumeta0/db2/keystore/* /tmp/keystore; chmod -R 777 /tmp/keystore" db2inst1 || exit $?
              oc rsync ${DB2_NAMESPACE}/c-${DB2_INSTANCE_NAME:0:-4}-db2u-0:/tmp/keystore/ /tmp
              oc rsync /tmp/keystore ${DB2_NAMESPACE}/c-${DB2_INSTANCE_NAME}-db2u-0:/tmp
              oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME}-db2u-0 -- su -lc "mv /mnt/blumeta0/db2/keystore/keystore.p12 /mnt/blumeta0/db2/keystore/keystore.p12_orig; mv /mnt/blumeta0/db2/keystore/keystore.sth /mnt/blumeta0/db2/keystore/keystore.sth_orig; cp /tmp/keystore/keystore.* /mnt/blumeta0/db2/keystore/; chown db2inst1.db2iadm1 /mnt/blumeta0/db2/keystore/keystore.*; chmod 600 /mnt/blumeta0/db2/keystore/keystore.*;" db2inst1 || exit $?


              # Restore in standby
              # echo ""
              # echo "Restoring ${timestamp} in standby server"
              # echo "--------------------------------------------------------------------------------"
              # oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME}-db2u-0 -- su -lc "db2 drop db ${DB2_DBNAME}; db2 restore db ${DB2_DBNAME} taken at ${timestamp}" db2inst1 | | exit $?

              # # Start hadr in standby
              # echo ""
              # echo "Starting HADR in standby"
              # echo "--------------------------------------------------------------------------------"
              # oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME}-db2u-0 -- su -lc "db2stop force; db2start; db2 start hadr on db bludb as standby; | tee /tmp//start_hadr_standby.log" db2inst1 || exit $?

              # # Start hadr in Primary
              # echo ""
              # echo "Starting HADR in standby"
              # echo "--------------------------------------------------------------------------------"
              # oc exec -n ${DB2_NAMESPACE} c-${DB2_INSTANCE_NAME:0:-4}-db2u-0 -- su -lc "db2stop force; db2start; db2 start hadr on db bludb as primary; | tee /tmp//start_hadr_primary.log" db2inst1 || exit $?
              exit 0
{{ end }}