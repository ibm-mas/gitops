{{- if and (eq .Values.mas_app_id "manage") (.Values.run_sanity_test) }}

# A sanity test is one that can be disruptive i.e. it can create new users, call authenticated apis, creates resources 
# in the application. This type of test should only be run in a downstream environment such as a dev or staging env
# The control over if these tests run or not is controlled by the `run_sanity_test` boolean in the values

{{ $ns               :=  .Values.mas_app_namespace }}
{{ $np_name          :=  "postsync-sanity-manage-np" }}
{{ $role_name        :=  "postsync-sanity-manage-role" }}
{{ $sa_name          :=  "postsync-sanity-manage-sa" }}
{{ $rb_name          :=  "postsync-sanity-manage-rb" }}
{{ $tests_cm_name    :=  "postsync-sanity-tests-manage-cm" }}
{{ $record_cm_name   :=  "postsync-sanity-tests-manage-record-cm" }}
{{ $job_name         :=  "postsync-sanity-manage-job" }}



---
# Permit outbound communication by the Job pod
# (Needed to communicate with the K8S HTTP API, PyPI, manage Route)
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: {{ $np_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  podSelector:
    matchLabels:
      app: {{ $job_name }}
  egress:
    - {}
  policyTypes:
    - Egress


---
kind: ServiceAccount
apiVersion: v1
metadata:
  name: {{ $sa_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}



---
# -------------------------------------
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $role_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
  - verbs:
      - get
      - list
    apiGroups:
      - "apps.mas.ibm.com"
      - "route.openshift.io"
      - "config.mas.ibm.com"
      - ""
    resources:
      - manageworkspace
      - manageapp
      - manageworkspaces
      - manageapps
      - secrets
      - routes
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $rb_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "601"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: {{ $sa_name }}
    namespace: {{ $ns }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $role_name }}
# -------------------------------------


---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $tests_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "602"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  requirements.txt: |-
    pytest
    kubernetes
    openshift
    ibm_db==3.2.3
    requests==2.31.0
    assertpy==1.1
  tests.py: |-
    from kubernetes import client,config
    from kubernetes.client import Configuration
    from openshift.dynamic import DynamicClient
    import pytest
    import os
    import ibm_db
    import requests
    import random
    import json
    import logging
    import base64
    from assertpy import assert_that
    from pathlib import Path
    from urllib.parse import urlparse
    logger = logging.getLogger()
    apikey=""
    siteid=""
    currency=""
    orgid=""
    setid=""
    csetid=""
    currobject=""
    MANAGE_URL = ""
    MAS_ADMIN_USERNAME = "" 
    MAS_ADMIN_PASSWORD = ""
    MANAGE_JDBC_URL = "" 
    MANAGE_JDBC_USERNAME = "" 
    MANAGE_JDBC_PASSWORD = ""
    MANAGE_JDBC_DRIVER = ""
    MANAGE_JDBC_SCHEMA = ""
    MANAGE_JDBC_CERT = ""
    nextval = ""
    schema = ""

    mas_instance_id = os.getenv("MAS_INSTANCE_ID")
    if mas_instance_id is None:
      raise Exception(f"Required MAS_INSTANCE_ID environment variable is not set")

    # e.g. "masdev"
    mas_workspace_id = os.getenv("MAS_WORKSPACE_ID")
    if mas_workspace_id is None:
      raise Exception(f"Required MAS_WORKSPACE_ID environment variable is not set")

    manage_namespace = f"mas-{mas_instance_id}-manage"
    manage_route_name = f"{mas_instance_id}-{mas_workspace_id}"

    @pytest.fixture(scope="session")
    def dyn_client():
      if "KUBERNETES_SERVICE_HOST" in os.environ:
        config.load_incluster_config()
        k8s_config = Configuration.get_default_copy()
        k8s_client = client.api_client.ApiClient(configuration=k8s_config)
      else:
        k8s_client = config.new_client_from_config()
      dyn_client = DynamicClient(k8s_client)
      yield dyn_client

    @pytest.fixture(scope="session")
    def v1_manageworkspace(dyn_client):
      yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')

    @pytest.fixture(scope="session")
    def v1_manageapp(dyn_client):
      yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageApp')

    @pytest.fixture(scope="session")
    def mange_workspace_reconciled_version(mange_workspace_cr):
      try:
        yield mange_workspace_cr['status']['versions']['reconciled']
      except KeyError as e:
        assert False, f"Unable to determine ManageWorkspace reconciled version. Error details: {e}"

    @pytest.fixture(scope="session")
    def manage_version(mange_app_cr):
      try:
        yield mange_app_cr['status']['components']['manage']['version']
      except KeyError as e:
        assert False, f"Unable to determine ManageApp component version. Error details: {e}"

    @pytest.fixture(scope="session")
    def mange_workspace_cr(v1_manageworkspace):
      yield v1_manageworkspace.get(namespace=manage_namespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}, mas.ibm.com/workspaceId={mas_workspace_id}").items[0]

    @pytest.fixture(scope="session")
    def mange_app_cr(v1_manageapp):
      yield v1_manageapp.get(namespace=manage_namespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}").items[0]

    @pytest.fixture(scope="session")
    def v1_secrets(dyn_client):
      yield dyn_client.resources.get(api_version='v1', kind='Secret')

    @pytest.fixture(scope="session")
    def v1_routes(dyn_client):
      yield dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')

    @pytest.fixture(scope="session")
    def manage_route(v1_routes):
      yield v1_routes.get(name=manage_route_name, namespace=manage_namespace)

    @pytest.fixture(scope="session")
    def manage_host(manage_route):
      try:
        yield manage_route['spec']['host']
      except KeyError as e:
        assert False, f"Unable to determine Manage host; spec.host key not present in {manage_route_name}/{manage_namespace}: {manage_route}. Error details: {e}"

    # Obtain Manage Details
    def test_getManageComponents(dyn_client):
      instanceId = os.getenv("MAS_INSTANCE_ID")
      workspaceId = os.getenv("MAS_WORKSPACE_ID")
      manage_namespace = f"mas-{mas_instance_id}-manage"
      manageWorkspaces = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
      try:
          manageWorkspaceInstance = manageWorkspaces.get(name=f'{instanceId}-{workspaceId}', namespace=manage_namespace)
      except Exception:
          logger.info(f'ApiException: Failed to retrieve {instanceId}-{workspaceId} instance of ManageWorkspace in namespace {manage_namespace}')
      manageComponentListInStr = ",".join(list(manageWorkspaceInstance['spec']['components'].keys()))
      logger.info(f'{manageComponentListInStr}') # like this: base,health,nuclear

    def test_getClusterInfo(dyn_client):
      instanceId = os.getenv("MAS_INSTANCE_ID")
      workspaceId = os.getenv("MAS_WORKSPACE_ID")
      manage_namespace = f"mas-{mas_instance_id}-manage"
      manageDBCredential = f'jdbc-mas-{instanceId}-{workspaceId}-manage-credentials'
      manageWorkspaceCR = None
      try:
          manageWorkspaceCRD = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
          manageWorkspaceCR = manageWorkspaceCRD.get(name=f'{instanceId}-{workspaceId}', namespace=manage_namespace)
      except Exception:
          logger.info("######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")

      # -------------------------------
      # Obtain DB Driver
      # -------------------------------

      manageDeployments = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageDeployment')
      try:
          manageDeploymentInstance = manageDeployments.get(name=f'manage-maxinst', namespace=manage_namespace)
          dbDriver = (manageDeploymentInstance['spec']['db']['maximoDBdriver'])
          dbSchema = (manageDeploymentInstance['spec']['db']['maximoDBschema'])
      
      except Exception:
          logger.info(f'ApiException: Failed to retrieve manage-maxinst instance of ManageWorkspace in namespace {manage_namespace}')   

      # -------------------------------
      # Obtain MAS URL
      # -------------------------------
      masNamespace = os.getenv("MAS_NAMESPACE")

      # -------------------------------
      # Obtain Manage URL
      # -------------------------------
      try:
          manageRouteDetails = dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')
          logger.info(manageRouteDetails)
          manageUrl = manageRouteDetails.get(name=f'{instanceId}-manage-{workspaceId}', namespace=manage_namespace)
      except Exception as e:
          if e.status == 404:
              logger.info(f"Unable to find route {instanceId}-manage-{workspaceId} in {manage_namespace}")

      # -------------------------------
      # Obtain JDBC credentials
      # -------------------------------
      try:
          jdbcCfgDetails = dyn_client.resources.get(api_version='config.mas.ibm.com/v1', kind='JdbcCfg')
          bindingManage = manageWorkspaceCR.spec.bindings.jdbc
      except Exception as ex:
          logger.info("######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")
      
      logger.info(f"ManageWorkspace has jdbc binding set to {bindingManage}")

      if "system" in bindingManage:
          jdbcCfgInstName = f'{instanceId}-jdbc-system'
      elif "workspace-application" in bindingManage:
          jdbcCfgInstName = f'{instanceId}-jdbc-wsapp-{workspaceId}-manage'
      else:
          logger.info("######### WARN: Unknown jdbc binding found in ManageWorkspace")

      try:
          masNamespace = "mas-fvtsaas-core"
          jdbcCfg = jdbcCfgDetails.get(name=jdbcCfgInstName, namespace=masNamespace)
          credentialsSecret = jdbcCfg.spec.config.credentials.secretName
          secrets = dyn_client.resources.get(api_version='v1', kind='Secret')
          credentials = secrets.get(credentialsSecret, masNamespace)
      except Exception:
          logger.info("ApiException: Failed to retrieve Manage database details. Check ManageWorkspace jdbc binding spec")

      # -------------------------------
      # Obtain Superuser credentials
      # -------------------------------
      # secrets = dyn_client.resources.get(api_version='v1', kind='Secret')
      # superuserCredentials = secrets.get(instanceId+'-credentials-superuser', masNamespace)

      # -------------------------------
      # Generate the DBC cert file
      # -------------------------------
      try:
          with open('db2-tls.cert', 'w') as f:
              f.write(jdbcCfg.spec.certificates[0].crt)
      except TypeError:
          logger.info("######### WARN: Database certificates not found")

      # -------------------------------
      # Output to be recovered by caller sh
      # -------------------------------

      global MAS_ADMIN_USERNAME, MAS_ADMIN_PASSWORD,MANAGE_URL,MANAGE_JDBC_URL,MANAGE_JDBC_USERNAME,MANAGE_JDBC_PASSWORD,MANAGE_JDBC_DRIVER,MANAGE_JDBC_SCHEMA,MANAGE_JDBC_CERT
      MANAGE_JDBC_URL=jdbcCfg.spec.config.url
      MANAGE_JDBC_USERNAME=credentials.get("username")
      MANAGE_JDBC_PASSWORD=credentials.get("password")
      logger.info(MANAGE_JDBC_URL)
      logger.info(MANAGE_JDBC_USERNAME)
      logger.info(MANAGE_JDBC_PASSWORD)
      if manageUrl is not None:
        MANAGE_URL="https://"+manageUrl.spec.host+manageUrl.spec.path+"maximo"
        logger.info(MANAGE_URL)
      MAS_ADMIN_USERNAME="maxadmin"
      logger.info(MAS_ADMIN_USERNAME)
      MAS_ADMIN_PASSWORD="maxadmin1234567"
      logger.info(MAS_ADMIN_PASSWORD)
      MANAGE_JDBC_DRIVER=dbDriver
      logger.info(MANAGE_JDBC_DRIVER)
      MANAGE_JDBC_SCHEMA=dbSchema
      logger.info(MANAGE_JDBC_SCHEMA)
      MANAGE_JDBC_CERT="./db2-tls.cert"
      logger.info(MANAGE_JDBC_CERT)

    # Manage db configuration
    @pytest.fixture(scope="session")
    def manage_db_connection():
        url = MANAGE_JDBC_URL.replace("jdbc:", "") if MANAGE_JDBC_URL is not None else None
        jdbcDetails = urlparse(url)
        db_config = {
            "database": jdbcDetails.path.replace("/", "").split(":")[0],
            "hostname": jdbcDetails.hostname,
            "port": jdbcDetails.port,
            "protocol": "TCPIP",
            "user": MANAGE_JDBC_USERNAME if 'MANAGE_JDBC_USERNAME' in globals() else None,
            "password": MANAGE_JDBC_PASSWORD if 'MANAGE_JDBC_PASSWORD' in globals() else None,
            "cert": MANAGE_JDBC_CERT if 'MANAGE_JDBC_CERT' in globals() else None,
            "driver": MANAGE_JDBC_DRIVER if 'MANAGE_JDBC_DRIVER' in globals() else None
        }
        
        # Check database type
        # -----------------------------------------------------------------------------
        # DB2 - with and without certification
        if "DB2" in db_config["driver"]:
            logger.info("=== DB2 Database -- Setting up connection ===")

            # Validate if certification is not empty
            ValidCert = False
            cert_path = MANAGE_JDBC_CERT if 'MANAGE_JDBC_CERT' in globals() else None
            if cert_path is not None:
                cert_file = Path(cert_path)
                logger.info(f"Certificate location:{cert_path}")
                if cert_file.exists():
                    file = open(MANAGE_JDBC_CERT, "r")
                    for line in file:
                        if re.search("CERTIFICATE", line):
                            ValidCert = True

            conn_str = (
                f"DATABASE={db_config['database']};HOSTNAME={db_config['hostname']};PORT={db_config['port']};PROTOCOL={db_config['protocol']};UID={db_config['user']};PWD={db_config['password']};"
                + (
                    f"SECURITY=SSL;SSLServerCertificate={db_config['cert']};"
                    if ValidCert
                    else f""
                )
            )
            connection = ibm_db.connect(conn_str, "", "")
            yield connection
            ibm_db.close(connection)

    def test_updateMaxadminGroup(manage_db_connection):
        global nextval,schema
        nextval = ("NEXT VALUE" if "dbo" in MANAGE_JDBC_SCHEMA else "NEXTVAL")
        schema = ("" if "dbo" in MANAGE_JDBC_SCHEMA else (MANAGE_JDBC_SCHEMA+"."))
        os_query = f"""select app from {schema}applicationauth
        where app in ('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET','MXEXTSYSTEM', 'INTOBJECT', 'MXAPIINTOBJECT', 'MXAPIMAXAPP','MXAPIPERUSER') 
        and groupname='MAXADMIN';
        """
        result_set = fetchBoth(manage_db_connection,os_query)
        if result_set:
            logger.info("Some object structure is already there as %s", result_set)
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIPERSONGROUP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIPROP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIGROUP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXASSET', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXEXTSYSTEM', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'INTOBJECT', 'MAXADMIN')        
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIINTOBJECT', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIMAXAPP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIPERUSER', 'MAXADMIN')
        else:
            logger.info(
                "No required object structure is present in MAXADMIN. Hence, updating MAXADMIN group."
            )
            update_query = (
                f"""insert into {schema}applicationauth 
                (groupname, app, optionname, applicationauthid) select 'MAXADMIN', app, optionname, 
                {nextval} for {schema}applicationauthseq from {schema}sigoption where app in 
                ('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET',
                'MXEXTSYSTEM', 'INTOBJECT', 'MXAPIINTOBJECT', 'MXAPIMAXAPP','MXAPIPERUSER');"""
            )
            executeQuery(manage_db_connection, update_query)
            logger.info("Object Structure permission successfully granted to MAXADMIN")

    def fetchBoth(manage_db_connection,stmt):
        #DB2
        response=ibm_db.exec_immediate(manage_db_connection, stmt)
        return ibm_db.fetch_both(response)

    def fetchTuple(manage_db_connection,stmt):
        response=ibm_db.exec_immediate(manage_db_connection, stmt)
        return ibm_db.fetch_tuple(response)

    def executeQuery(manage_db_connection, stmt):
        ibm_db.exec_immediate(manage_db_connection, stmt)
        
    def updateSpecificPermissionToGroup(manage_db_connection, application, group):

        # Check if app/os permission is already present
        select_query = f"""select app from {schema}applicationauth 
        where app in ('{application}') AND groupname='{group}';
        """
        resultSet = fetchBoth(manage_db_connection,select_query)

        if(resultSet):
            logger.info(f"Few permission for app {application} already present. Applying all permissions now..")
            delete_query = f"""delete from {schema}applicationauth where app in ('{application}') and groupname='{group}';"""
            executeQuery(manage_db_connection, delete_query)
            update_after_delete_query = f"""insert into {schema}applicationauth (groupname, app, optionname, applicationauthid)
            select '{group}', app, optionname, {nextval} for {schema}applicationauthseq from {schema}sigoption
            where app in ('{application}');"""
            logger.info(update_after_delete_query)
            executeQuery(manage_db_connection, update_after_delete_query)
            logger.info(f"All permission for {application} applied successfully.")
        else:
            logger.info(f"Adding permission for app {application} to {group}")
            update_query = f"""insert into {schema}applicationauth (groupname, app, optionname, applicationauthid)
            select '{group}', app, optionname, {nextval} for {schema}applicationauthseq from {schema}sigoption
            where app in ('{application}');"""
            executeQuery(manage_db_connection, update_query)
            logger.info(f"Added all permission for {application} to {group} successfully.")

    def test_generatekey():
        global apikey
        maxauth=str(MAS_ADMIN_USERNAME+":"+MAS_ADMIN_PASSWORD)
        base64_maxauth = base64.b64encode(maxauth.encode("utf-8"))
        maxauth = base64_maxauth.decode("utf-8")
        url = MANAGE_URL+"/api/apitoken/create"
        payload = {"expiration": -1}
        headers = {
            "Content-Type": "application/json",
            "maxauth":maxauth
        }
        response = requests.request("POST", url, json=payload, headers=headers).json()
        apikey=response['apikey']

    def test_generateObjectStructureforCurrency():
        url = MANAGE_URL+"/api/os/mxintobject"
        global currobject
        querystring = {"lean":"1"}
        currobject="MXCUR"+str(random.randint(0,100))
        payload = {
            "intobjectname": currobject,
            "description": "API Automation - "+currobject,
            "usewith": "INTEGRATION",
            "authapp": "MXAPIINTOBJECT",
            "maxintobjdetail": {"objectname": "CURRENCY"}
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)

    def test_create_currency():
        global currency
        currency="curr"+str(random.randint(0,100))
        logger.info(currency)

        url = MANAGE_URL+"/api/os/"+currobject

        querystring = {"lean":"1"}

        payload = {
            "currencycode": currency,
            "description": currency+" Description"
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_create_item_set():
        url = MANAGE_URL+"/api/os/mxapisets"
        global setid
        setid="itset"+str(random.randint(5,100))

        querystring = {"lean":"1"}

        payload = {
            "settype_description": "Item Sets",
            "settype": "ITEM",
            "setid": setid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(201)
        
    def test_create_company_set():
        url = MANAGE_URL+"/api/os/mxapisets"
        global csetid
        csetid="comset"+str(random.randint(5,100))
        querystring = {"lean":"1"}
        payload = {
            "settype_description": "Item Sets",
            "settype": "COMPANY",
            "setid": csetid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        
    def test_create_org():
        url = MANAGE_URL+"/api/os/mxapiorganization"
        global siteid,orgid
        querystring = {"lean":["1","1"]}
        orgid="org"+str(random.randint(0,1000))
        logger.info(orgid)
        
        payload = {
            "active": False,
            "dfltitemstatus_description": "Active",
            "orgid": orgid,
            "basecurrency1": currency,
            "companysetid": csetid,
            "organizationid": 7,
            "description": "MY ORG IN GUJARAT",
            "dfltitemstatus": "ACTIVE",
            "itemsetid": setid,
            "category": "NS"
        }
        headers = {
            
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlCompany():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (111)",
            "glorder": 0,
            "active": True,
            "compvalue": 111,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlCompany2():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (222)",
            "glorder": 1,
            "active": True,
            "compvalue": 222,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlCompany3():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (333)",
            "glorder": 2,
            "active": True,
            "compvalue": 333,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlAccount():
        url = MANAGE_URL+"/api/os/MXAPICOA"

        querystring = {"lean":"1"}

        payload = {
            "glaccount": "111-222-333",
            "accountname": "111-222-333",
            "active": True,
            "glcomp01": "111",
            "glcomp02": "222",
            "glcomp03": "333",
            "orgid": orgid
        }
        headers = {
            
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)

        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(requests.codes.created)

    def test_updateOrgToActiveSiteAndGL():
        url = MANAGE_URL+"/api/os/mxapiorganization"
        global siteid
        orgid2= "orgid=\""+orgid+"\""
        logger.info(orgid2)
        querystring = {"lean":["1","1"],"oslc.select":"*","oslc.where":orgid2}
        logger.info(querystring)

        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("GET", url, headers=headers, params=querystring)
        logger.info("response")
        jsonresponse=response.json()

        logger.info(jsonresponse['member'][0]['organizationid'])
        orgid3=jsonresponse['member'][0]['organizationid']

        url = MANAGE_URL+"/api/os/mxapiorganization/"+str(orgid3)
        siteid="site"+str(random.randint(0,100))
        logger.info(siteid)
        querystring = {"lean":["1","1"]}

        payload = {
            "site": [
                {
                    "description_longdescription": "Automation Site 1",
                    "active": True,
                    "description": "Automation Site 1",
                    "siteid": siteid
                }
            ],
            "clearingacct": "111-222-333",
            "active": True
        }
        headers = {
        
            "Content-Type": "application/json",
            "x-method-override": "PATCH",
            "patchtype": "MERGE",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(204)

    def test_create_user():
        url = MANAGE_URL+"/api/os/mxapiperuser"
        querystring = {"lean":"1"}
        personid="person"+str(random.randint(0,100))
        payload = {
            "personid": personid,
            "firstname": "first"+str(random.randint(0,100)),
            "lastname": "last"+str(random.randint(0,100)),
            "primaryemail": personid+"@yahoo.com",
            "primaryphone": "999 999 9999",
            "city": "Boston",
            "addressline1": "crazy road",
            "stateprovince": "MA",
            "postalcode": "01111",
            "country": "US",
            "language": "EN",
            "maxuser": [
                {
                    "loginid": personid,
                    "passwordcheck": personid,
                    "passwordinput": personid,
                    "defsite": "BEDFORD",
                    "type": "TYPE 1",
                    "userid": personid
                }
            ]
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)



---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $job_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "604"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  template:
    metadata:
      labels:
        app: {{ $job_name }}
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 8 }}
{{- end }}
    spec:
      imagePullSecrets: []
      containers:
        - name: run
          image: quay.io/ibmmas/cli:latest
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 200m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 64Mi
          env:
            - name: MAS_INSTANCE_ID
              value: "{{ .Values.instance_id }}"
            - name: MAS_WORKSPACE_ID
              value: "{{ .Values.mas_workspace_id }}"
            - name: MAS_NAMESPACE
              value: "{{ .Values.mas_app_namespace }}"
          volumeMounts:
            - name: tests
              mountPath: /tmp/tests
          command:
            - /bin/sh
            - -c
            - |
              python -m venv .venv
              source .venv/bin/activate
              pip install -r /tmp/tests/requirements.txt
              pytest -o cache_dir=/tmp/__pycache__ /tmp/tests/tests.py 
      restartPolicy: Never
      serviceAccountName: {{ $sa_name }}
      volumes:
        - name: tests
          configMap:
            name: {{ $tests_cm_name }}
            items:
              - key: requirements.txt
                path: requirements.txt
              - key: tests.py
                path: tests.py
            defaultMode: 420
            optional: false
  backoffLimit: 4

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $record_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "605"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
  labels:
    type: mas-app-verification-record
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  mas_app: "manage"
  mas_catalog_version: "{{ .Values.mas_catalog_version }}"

{{- end }}
