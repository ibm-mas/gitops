{{- if and (eq .Values.mas_app_id "manage") (.Values.run_sanity_test) }}

# A sanity test is one that can be disruptive i.e. it can create new users, call authenticated apis, creates resources 
# in the application. This type of test should only be run in a downstream environment such as a dev or staging env
# The control over if these tests run or not is controlled by the `run_sanity_test` boolean in the values

{{ $ns               :=  .Values.mas_app_namespace }}
{{ $np_name          :=  "postsync-sanity-manage-np" }}
{{ $role_name        :=  "postsync-sanity-manage-role" }}
{{ $crole_name       :=  printf "postsync-sanity-manage-crole-%s" .Values.instance_id }}
{{ $sa_name          :=  printf "postsync-sanity-manage-sa-%s" .Values.instance_id }}
{{ $rb_name          :=  "postsync-sanity-manage-rb" }}
{{ $crb_name         :=  printf "postsync-sanity-manage-crb-%s" .Values.instance_id }}
{{ $tests_cm_name    :=  "postsync-sanity-tests-manage-cm" }}
{{ $record_cm_name   :=  "postsync-sanity-tests-manage-record-cm" }}
{{ $job_name         :=  "postsync-sanity-manage-job" }}



---
# Permit outbound communication by the Job pod
# (Needed to communicate with the K8S HTTP API, PyPI, manage Route)
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: {{ $np_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  podSelector:
    matchLabels:
      app: {{ $job_name }}
  egress:
    - {}
  policyTypes:
    - Egress


---
kind: ServiceAccount
apiVersion: v1
metadata:
  name: {{ $sa_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}



---
# -------------------------------------
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $role_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
  - verbs:
      - get
      - list
    apiGroups:
      - "apps.mas.ibm.com"
    resources:
      - manageworkspace
      - manageapp
      - manageworkspaces
      - manageapps
  - verbs:
      - get
      - list
      - patch
    apiGroups:
      - ""
    resources:
      - configmaps
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $rb_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "601"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: {{ $sa_name }}
    namespace: {{ $ns }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $role_name }}
# -------------------------------------

---
# -------------------------------------
# Manage Verification tests need to be able to get jdbc and superuser credentials from Core
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $crole_name }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
  - verbs:
      - get
      - list
    apiGroups:
      - "apps.mas.ibm.com"
      - "route.openshift.io"
      - "config.mas.ibm.com"
      - "core.mas.ibm.com"
      - ""
    resources:
      - manageworkspace
      - manageapp
      - manageworkspaces
      - manageapps
      - secrets
      - routes
      - suites

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $crb_name }}
  annotations:
    argocd.argoproj.io/sync-wave: "601"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: {{ $sa_name }}
    namespace: {{ $ns }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ $crole_name }}
# -------------------------------------

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $tests_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "602"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  requirements.txt: |-
    pytest
    kubernetes
    openshift
    ibm_db==3.2.3
    requests==2.31.0
    assertpy==1.1
    urllib3==1.26.18
  tests.py: |-
    from kubernetes import client,config
    from kubernetes.client import Configuration
    from openshift.dynamic import DynamicClient
    import pytest
    import os
    import urllib3
    import requests
    import certifi
    import random
    import logging
    import tempfile
    import base64
    from assertpy import assert_that
    import time

    logger = logging.getLogger()
    authToken=""
    MANAGE_URL = ""
    MAS_URL = ""
    MAS_APIURL = ""
    MAS_ADMIN_USERNAME = "" 
    MAS_ADMIN_PASSWORD = ""
    MANAGE_JDBC_URL = "" 
    MANAGE_JDBC_USERNAME = "" 
    MANAGE_JDBC_PASSWORD = ""
    MANAGE_JDBC_DRIVER = ""
    MANAGE_JDBC_SCHEMA = ""
    MANAGE_JDBC_CERT = ""
    admin_api_key = ""
    user_api_key = ""
    user_id="maxadmin"  #admin user
    nextval = ""
    schema = ""
    manage_user="saasuser"+str(random.randint(0,10000))
    manage_user_password=manage_user+str(random.randint(0,100))
    asset="sanity"+str(random.randint(0,1000))
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    session = requests.Session()

    mas_instance_id = os.getenv("MAS_INSTANCE_ID")
    if mas_instance_id is None:
        raise Exception(f"Required MAS_INSTANCE_ID environment variable is not set")

    # e.g. "masdev"
    mas_workspace_id = os.getenv("MAS_WORKSPACE_ID")
    if mas_workspace_id is None:
        raise Exception(f"Required MAS_WORKSPACE_ID environment variable is not set")

    manageNamespace = f"mas-{mas_instance_id}-manage"
    masNamespace = f"mas-{mas_instance_id}-core"
    manage_route_name = f"{mas_instance_id}-manage-{mas_workspace_id}"

    @pytest.fixture(scope="session")
    def dyn_client():
        if "KUBERNETES_SERVICE_HOST" in os.environ:
            config.load_incluster_config()
            k8s_config = Configuration.get_default_copy()
            k8s_client = client.ApiClient(configuration=k8s_config)
        else:
            k8s_client = config.new_client_from_config()

        dyn_client = DynamicClient(k8s_client)
        dyn_client.namespace = manageNamespace
        yield dyn_client

    @pytest.fixture(scope="session")
    def dyn_client_mas_core():
        if "KUBERNETES_SERVICE_HOST" in os.environ:
            config.load_incluster_config()
            k8s_config = Configuration.get_default_copy()
            k8s_client = client.ApiClient(configuration=k8s_config)
        else:
            k8s_client = config.new_client_from_config()

        dyn_client = DynamicClient(k8s_client)
        dyn_client.namespace = masNamespace
        yield dyn_client

    @pytest.fixture(scope="session")
    def v1_manageworkspace(dyn_client):
        yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')

    @pytest.fixture(scope="session")
    def v1_manageapp(dyn_client):
        yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageApp')

    @pytest.fixture(scope="session")
    def mange_workspace_reconciled_version(mange_workspace_cr):
        try:
            yield mange_workspace_cr['status']['versions']['reconciled']
        except KeyError as e:
            assert False, f"Unable to determine ManageWorkspace reconciled version. Error details: {e}"

    @pytest.fixture(scope="session")
    def manage_version(mange_app_cr):
        try:
            yield mange_app_cr['status']['components']['manage']['version']
        except KeyError as e:
            assert False, f"Unable to determine ManageApp component version. Error details: {e}"

    @pytest.fixture(scope="session")
    def mange_workspace_cr(v1_manageworkspace):
        yield v1_manageworkspace.get(namespace=manageNamespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}, mas.ibm.com/workspaceId={mas_workspace_id}").items[0]

    @pytest.fixture(scope="session")
    def mange_app_cr(v1_manageapp):
        yield v1_manageapp.get(namespace=manageNamespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}").items[0]

    @pytest.fixture(scope="session")
    def v1_secrets(dyn_client):
        yield dyn_client.resources.get(api_version='v1', kind='Secret')

    @pytest.fixture(scope="session")
    def v1_routes(dyn_client):
        yield dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')

    @pytest.fixture(scope="session")
    def manage_route(v1_routes):
        yield v1_routes.get(name=manage_route_name, namespace=manageNamespace)

    @pytest.fixture(scope="session")
    def manage_host(manage_route):
        try:
            yield manage_route['spec']['host']
        except KeyError as e:
            assert False, f"Unable to determine Manage host; spec.host key not present in {manage_route_name}/{manageNamespace}: {manage_route}. Error details: {e}"

    @pytest.fixture(scope="session")
    def manage_host_ca_filepath(manage_route):

      # Read the certificate field from the Manage Route. 
      # This may include CA certificates that we need in order to trust the certificates presented by the external Manage endpoint.
      try:
        manage_route_certificate = manage_route['spec']['tls']['certificate']
      except KeyError as e:
        pass

      # Read the caCertificate field from the Manage Route. 
      # This may include CA certificates that we need in order to trust the certificates presented by the external Manage endpoint.
      try:
        manage_route_caCertificate = manage_route['spec']['tls']['caCertificate']
      except KeyError as e:
        pass

      # Read the destinationCACertificate field from the Manage Route. 
      # This may include CA certificates that we need in order to trust the certificates presented by the internal Manage services.
      try:
        manage_route_destinationCACertificate = manage_route['spec']['tls']['destinationCACertificate']
      except KeyError as e:
        pass

      # Load default CA bundle. This will include certs for well-known CAs. This ensures that we will
      # trust the certificates presented by the external Manage endpoints when MAS is configured to use
      # an external frontend like CIS.
      with open(certifi.where(), 'rb') as default_ca:
        default_ca_content = default_ca.read()

      # Combine all of the above into a single .pem file that we can use when issuing HTTP requests
      chain_file = tempfile.NamedTemporaryFile(delete=False)
      try:
        
        if manage_route_certificate:
          chain_file.write(manage_route_certificate.encode())
        
        if manage_route_caCertificate:
          chain_file.write(manage_route_certificate.encode())

        if manage_route_destinationCACertificate:
          chain_file.write(manage_route_destinationCACertificate.encode())

        chain_file.write(default_ca_content)

        chain_file.flush()
        chain_file.close()

        yield chain_file.name

      finally:
        os.remove(chain_file.name)


    # Obtain Manage Details
    def test_getManageComponents(dyn_client):
        manageWorkspaces = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
        try:
            manageWorkspaceInstance = manageWorkspaces.get(name=f'{mas_instance_id}-{mas_workspace_id}', namespace=manageNamespace)
        except Exception:
            logger.info(f'ApiException: Failed to retrieve {mas_instance_id}-{mas_workspace_id} instance of ManageWorkspace in namespace {manageNamespace}')
        manageComponentListInStr = ",".join(list(manageWorkspaceInstance['spec']['components'].keys()))
        logger.info(f'{manageComponentListInStr}') # like this: base,health,nuclear

    def test_getClusterInfo(dyn_client,dyn_client_mas_core):

        # Manage Workspace and Credentials
        manageDBCredential = f'jdbc-mas-{mas_instance_id}-{mas_workspace_id}-manage-credentials'
        manageWorkspaceCR = None

        # -------------------------------
        # Manage Workspace CR
        # -------------------------------
        try:
            manageWorkspaceCRD = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
            manageWorkspaceCR = manageWorkspaceCRD.get(name=f'{mas_instance_id}-{mas_workspace_id}', namespace=manageNamespace)
        except Exception as ex:
            logger.info(f"######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")

        # -------------------------------
        # Manage Deployment DB Info
        # -------------------------------
        try:
            manageDeployments = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageDeployment')
            manageDeploymentInstance = manageDeployments.get(name='manage-maxinst', namespace=manageNamespace)
            dbDriver = manageDeploymentInstance['spec']['db']['maximoDBdriver']
            dbSchema = manageDeploymentInstance['spec']['db']['maximoDBschema']
        except Exception as ex:
            logger.info(f"ApiException: Failed to retrieve manage-maxinst instance in namespace {manageNamespace}: {str(ex)}")

        # -------------------------------
        # Obtain MAS URL
        # -------------------------------
        masRouteDetails = dyn_client_mas_core.resources.get(api_version='route.openshift.io/v1', kind='Route')
        masUrl = masRouteDetails.get(name=f'{mas_instance_id}-admin', namespace=masNamespace)
        masapiUrl = masRouteDetails.get(name=f'{mas_instance_id}-api', namespace=masNamespace)
        # -------------------------------
        # Manage URL (OpenShift Route)
        # -------------------------------
        try:
            manageRouteObject = dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')
            manageRouteDetails = manageRouteObject.get(name=f'{mas_instance_id}-manage-{mas_workspace_id}', namespace=manageNamespace)
            manageUrl = manageRouteDetails.spec.host
        except Exception as e:
            if e.status == 404:
                logger.info(f"Unable to find route {mas_instance_id}-manage-{mas_workspace_id} in {manageNamespace}")
            else:
                logger.info(f"Error retrieving route: {str(e)}")

        global MAS_ADMIN_USERNAME, MAS_ADMIN_PASSWORD, MANAGE_URL, MAS_URL, MAS_APIURL
        MAS_URL=f"https://{masUrl.spec.host}{masUrl.spec.path}"
        MAS_APIURL=f"https://{masapiUrl.spec.host}{masapiUrl.spec.path}"
        if manageUrl:
            #MANAGE_URL = f"https://{manageUrl}"
            #MANAGE_URL="https://127.0.0.1:9080"    # Use when run from Local. Do port forwarding...
            MANAGE_URL = f'https://{mas_instance_id}-{mas_workspace_id}.mas-{mas_instance_id}-manage.svc'  # Use for cluster
            
        global MANAGE_JDBC_URL, MANAGE_JDBC_USERNAME, MANAGE_JDBC_PASSWORD, MANAGE_JDBC_DRIVER, MANAGE_JDBC_SCHEMA, MANAGE_JDBC_CERT

        # -------------------------------
        # Obtain Superuser credentials
        # -------------------------------
        secrets = dyn_client_mas_core.resources.get(api_version='v1', kind='Secret')
        superuserCredentials = secrets.get(mas_instance_id+'-credentials-superuser', masNamespace)
        MAS_ADMIN_USERNAME_ENCODE = superuserCredentials.data.username
        MAS_ADMIN_USERNAME_BYTE = base64.b64decode(str(MAS_ADMIN_USERNAME_ENCODE))
        MAS_ADMIN_USERNAME = MAS_ADMIN_USERNAME_BYTE.decode("utf-8")
        MAS_ADMIN_PASSWORD_DECODE = superuserCredentials.data.password
        MAS_ADMIN_PASSWORD_BYTE = base64.b64decode(str(MAS_ADMIN_PASSWORD_DECODE))
        MAS_ADMIN_PASSWORD = MAS_ADMIN_PASSWORD_BYTE.decode("utf-8")
        # -------------------------------
        # JDBC Credentials
        # -------------------------------
        # try:
        #     jdbcCfgObj = dyn_client_mas_core.resources.get(api_version='config.mas.ibm.com/v1', kind='JdbcCfg')
        #     #jdbcCfgDetails = jdbcCfgObj.get(name=f'{mas_instance_id}-manage-{mas_workspace_id}', namespace=masNamespace)
        #     bindingManage = manageWorkspaceCR.spec.bindings.jdbc
        # except Exception as ex:
        #     logger.info(f"######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")
        # logger.info(f"ManageWorkspace has jdbc binding set to {bindingManage}")

        # if "system" in bindingManage:
        #     jdbcCfgInstName = f'{mas_instance_id}-jdbc-system'
        # elif "workspace-application" in bindingManage:
        #     jdbcCfgInstName = f'{mas_instance_id}-jdbc-wsapp-{mas_workspace_id}-manage'
        # else:
        #     logger.info("######### WARN: Unknown jdbc binding found in ManageWorkspace")

        # try:
        #     jdbcCfg = jdbcCfgObj.get(name=jdbcCfgInstName, namespace=masNamespace)
        #     credentialsSecret = jdbcCfg.spec.config.credentials.secretName
        #     secrets = dyn_client_mas_core.resources.get(api_version='v1', kind='Secret')
        #     credentials = secrets.get(name=credentialsSecret, namespace=masNamespace)
        # except Exception:
        #     logger.info("ApiException: Failed to retrieve Manage database details. Check ManageWorkspace jdbc binding spec")

        # # -------------------------------
        # # Database Certificate
        # # -------------------------------
        # if jdbcCfg is not None:
        #     try:
        #         with open('db2-tls.cert', 'w') as f:
        #             f.write(jdbcCfg.spec.certificates[0].crt)
        #     except Exception as e:
        #         logger.info(f"Error writing certificate: {str(e)}")
        # else:
        #     logger.info("JdbcCfg was not assigned. Skipping certificate writing.")

        # MANAGE_JDBC_URL = jdbcCfg.spec.config.url if jdbcCfg else None
        # MANAGE_JDBC_USERNAME = credentials.data.username
        # MANAGE_JDBC_PASSWORD = credentials.data.password
        # MANAGE_JDBC_DRIVER = dbDriver
        # MANAGE_JDBC_SCHEMA = dbSchema
        # MANAGE_JDBC_CERT = "./db2-tls.cert"

        logger.info(MANAGE_JDBC_URL)
        logger.info(MANAGE_JDBC_USERNAME)
        logger.info(MANAGE_JDBC_PASSWORD)
        logger.info(MAS_URL)
        logger.info(MAS_APIURL)
        logger.info(MANAGE_URL)
        logger.info(MAS_ADMIN_USERNAME)
        logger.info(MAS_ADMIN_PASSWORD)
        # logger.info(MANAGE_JDBC_DRIVER)
        # logger.info(MANAGE_JDBC_SCHEMA)
        # logger.info(MANAGE_JDBC_CERT)

    # # def manage_db_connection_and_update_permissions():

    # #     url = MANAGE_JDBC_URL.replace("jdbc:", "") if MANAGE_JDBC_URL is not None else None
    # #     jdbc_details = urlparse(url)
        
    # #     db_config = {
    # #         "database": jdbc_details.path.replace("/", "").split(":")[0],
    # #         "hostname": jdbc_details.hostname,
    # #         "port": jdbc_details.port,
    # #         "protocol": "TCPIP",
    # #         "user": globals().get('MANAGE_JDBC_USERNAME'),
    # #         "password": globals().get('MANAGE_JDBC_PASSWORD'),
    # #         "cert": globals().get('MANAGE_JDBC_CERT'),
    # #         "driver": globals().get('MANAGE_JDBC_DRIVER')
    # #     }

    # #     # Check DB2 database and validate certificate
    # #     if "DB2" in db_config["driver"]:
    # #         logger.info("=== DB2 Database -- Setting up connection ===")

    # #         # Certificate validation
    # #         cert_path = db_config["cert"]
    # #         valid_cert = cert_path and Path(cert_path).exists() and any("CERTIFICATE" in line for line in open(cert_path))
    # #         if cert_path:
    # #             logger.info(f"Certificate location: {cert_path}")
            
    # #         # Create connection string
    # #         conn_str = (
    # #             f"DATABASE={db_config['database']};HOSTNAME={db_config['hostname']};PORT={db_config['port']};"
    # #             f"PROTOCOL={db_config['protocol']};UID={db_config['user']};PWD={db_config['password']};"
    # #             + (f"SECURITY=SSL;SSLServerCertificate={db_config['cert']};" if valid_cert else "")
    # #         )
    # #         connection = ibm_db.connect(conn_str, "", "")
    # #         logger.info("Connection established successfully.")
            
    # #         try:
    # #             # Manage permissions
    # #             schema = "" if "dbo" in MANAGE_JDBC_SCHEMA else (MANAGE_JDBC_SCHEMA + ".")
    # #             nextval = "NEXT VALUE" if "dbo" in MANAGE_JDBC_SCHEMA else "NEXTVAL"

    # #             os_query = (
    # #                 f"SELECT app FROM {schema}applicationauth WHERE app IN "
    # #                 f"('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET','MXEXTSYSTEM','INTOBJECT','MXAPIINTOBJECT','MXAPIMAXAPP','MXAPIPERUSER') "
    # #                 f"AND groupname='MAXADMIN';"
    # #             )
                
    # #             result_set = fetch_both(connection, os_query)

    # #             if result_set:
    # #                 logger.info("Object structures already present: %s", result_set)
    # #                 update_permissions(connection, 'MXAPIPERSONGROUP', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'MXAPIPROP', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'MXAPIGROUP', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'MXASSET', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'MXEXTSYSTEM', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'INTOBJECT', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'MXAPIINTOBJECT', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'MXAPIMAXAPP', 'MAXADMIN', schema, nextval)
    # #                 update_permissions(connection, 'MXAPIPERUSER', 'MAXADMIN', schema, nextval)
    # #             else:
    # #                 logger.info("No required object structure found. Updating MAXADMIN group.")
    # #                 update_query = (
    # #                     f"INSERT INTO {schema}applicationauth (groupname, app, optionname, applicationauthid) "
    # #                     f"SELECT 'MAXADMIN', app, optionname, {nextval} FROM {schema}sigoption WHERE app IN "
    # #                     f"('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET','MXEXTSYSTEM','INTOBJECT','MXAPIINTOBJECT','MXAPIMAXAPP','MXAPIPERUSER');"
    # #                 )
    # #                 execute_query(connection, update_query)
    # #                 logger.info("Permissions successfully granted to MAXADMIN.")
    # #         finally:
    # #             ibm_db.close(connection)
    # #             logger.info("Connection closed.")

    # def fetch_both(connection, stmt):
    #     response = ibm_db.exec_immediate(connection, stmt)
    #     return ibm_db.fetch_both(response)

    # def execute_query(connection, stmt):
    #     ibm_db.exec_immediate(connection, stmt)

    # def update_permissions(connection, application, group, schema, nextval):
    #     # Check if permission is already present
    #     select_query = f"SELECT app FROM {schema}applicationauth WHERE app = '{application}' AND groupname = '{group}';"
    #     result_set = fetch_both(connection, select_query)

    #     if result_set:
    #         logger.info(f"Permissions for {application} already present. Reapplying permissions.")
    #         delete_query = f"DELETE FROM {schema}applicationauth WHERE app = '{application}' AND groupname = '{group}';"
    #         execute_query(connection, delete_query)

    #     # new permissions
    #     update_query = (
    #         f"INSERT INTO {schema}applicationauth (groupname, app, optionname, applicationauthid) "
    #         f"SELECT '{group}', app, optionname, {nextval} FROM {schema}sigoption WHERE app = '{application}';"
    #     )
    #     execute_query(connection, update_query)
    #     logger.info(f"Permissions for {application} applied successfully.")

    def test_create_super_user_token(manage_host_ca_filepath):
        url = MAS_URL+"logininitial"
        querystring = {"verify":"False"}

        payload = {
            "username": f"{MAS_ADMIN_USERNAME}",
            "password": f"{MAS_ADMIN_PASSWORD}"
        }
        headers = {
            "Content-Type": "application/json"
        }

        response = requests.post(url, json=payload, headers=headers, params=querystring, verify=manage_host_ca_filepath)
        global authToken
        authToken = response.json()["token"]
        logger.info(authToken)

    def test_v3_create_user(manage_host_ca_filepath):
        # GET Same User first and verify whether it is already present or NOT!
        url = MAS_APIURL + "v3/users/" + manage_user
        querystring = {"lean": "1"}
        headers = {
            "Content-Type": "application/json",
            "x-access-token": authToken
        }
        response = requests.get(url, headers=headers, params=querystring, verify=manage_host_ca_filepath)

        if response.status_code == 404:
            logger.info("User was not present and being created.....")
            create_user(manage_host_ca_filepath)
        elif response.status_code == 200:
            logger.info("User was already present, deleting first.....")
            # Keep deleting the user until a 404 status code is received
            while True:
                delete_response = delete_user(manage_host_ca_filepath)
                if delete_response.status_code == 404:
                    break
            # create the user as its deleted now
            create_user(manage_host_ca_filepath)

    def delete_user(manage_host_ca_filepath):
        url = MAS_APIURL + "v3/users/" + manage_user
        querystring = {"lean": "1"}
        headers = {
            "Content-Type": "application/json",
            "x-access-token": authToken
        }
        response = requests.delete(url, headers=headers, params=querystring, verify=manage_host_ca_filepath)
        logger.info(response.text)
        assert_that(response.status_code).is_in(204, 404)
        return response

    def create_user(manage_host_ca_filepath):
        url = MAS_APIURL + "v3/users"
        querystring = {"lean": "1"}
        payload = {
            "id": manage_user,
            "status": {"active": True},
            "username": manage_user,
            "token": manage_user_password,
            "owner": "local",
            "emails": [
                {
                    "value": f"{manage_user}_email@ibm.com",
                    "type": "Work",
                    "primary": True
                }
            ],
            "displayName": "Api default JSON User",
            "issuer": "local",
            "permissions": {
                "systemAdmin": True,
                "userAdmin": True
            },
            "entitlement": {
                "application": "PREMIUM",
                "admin": "ADMIN_PREMIUM",
                "alwaysReserveLicense": True
            },
            "title": "Mr.Sanity",
            "givenName": manage_user,
            "familyName": manage_user
        }
        headers = {
            "Content-Type": "application/json",
            "x-access-token": authToken
        }
        response = requests.post(url, json=payload, headers=headers, params=querystring, verify=manage_host_ca_filepath)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(201)

    def test_v3_user_link_to_idp(manage_host_ca_filepath):
        url = MAS_APIURL+"v3/users/"+manage_user+"/idps/local"  # url = "https://api.fvtsaas.ibmmasfvt.com/v3/users/saasuser/idps/local"
        querystring = {"emailPassword":"False"}
        payload = {"idpUserId": manage_user}
        headers = {
            "Content-Type": "application/json",
            "x-access-token": authToken
        }
        response = requests.put(url, json=payload, headers=headers, params=querystring, verify=manage_host_ca_filepath)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(200)

    def test_v3_user_add_user_to_workspace(manage_host_ca_filepath):
        url = MAS_APIURL+"workspaces/"+mas_workspace_id+"/users/"+manage_user  #url = "https://api.fvtsaas.ibmmasfvt.com/workspaces/masdev/users/saasUser"
        payload = {"permissions": {"workspaceAdmin": False}}
        headers = {
            "Content-Type": "application/json",
            "x-access-token": authToken
        }
        response = requests.put(url, json=payload, headers=headers, verify=manage_host_ca_filepath)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(200)

    def test_v3_user_application_permission(manage_host_ca_filepath):
        url = MAS_APIURL+"workspaces/"+mas_workspace_id+"/applications/manage/users/"+manage_user  #url = "https://api.fvtsaas.ibmmasfvt.com/workspaces/masdev/applications/manage/users/saasUser"
        payload = {"role": "MANAGEUSER"}
        headers = {
            "Content-Type": "application/json",
            "x-access-token": authToken
        }
        response = requests.put(url, json=payload, headers=headers, verify=manage_host_ca_filepath)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(200)

    def test_check_user_sync(manage_host_ca_filepath):
        headers = {"Authorization": f"Bearer {authToken}"}

        def get_user(manage_host_ca_filepath):
            url = f"{MAS_APIURL}/v3/users/{manage_user}"
            response = requests.get(url, headers=headers, verify=manage_host_ca_filepath)
            response.raise_for_status()  # Raises an exception for HTTP errors
            return response.json()

        # Obtain user just created to check sync status
        test_user = get_user(manage_host_ca_filepath)

        # Wait for sync status to become SUCCESS within 10 minutes
        logger.debug("Waiting for user coordinator to update sync status")
        t_end = time.time() + 60 * 10
        while time.time() < t_end:
            sync_state = test_user["applications"]["manage"]["sync"]["state"]
            if sync_state == "SUCCESS":
                break
            else:
                logger.debug(f"User sync has not been completed yet for app manage: {t_end - time.time():.2f} seconds remaining")
                time.sleep(5)
                # Re-check the user sync status
                test_user = get_user(manage_host_ca_filepath)

        # Verify the sync status is SUCCESS after timeout period
        assert test_user["applications"]["manage"]["sync"]["state"] == "SUCCESS"

    @pytest.fixture(scope="session")
    def client_cert(dyn_client):
        certSecretObj = dyn_client.resources.get(api_version='v1', kind='Secret')
        certSecret = certSecretObj.get(
            f"{mas_instance_id}-internal-manage-tls", f"mas-{mas_instance_id}-manage"
        )
        internal_cert = certSecret.data["tls.crt"]
        internal_key = certSecret.data["tls.key"]
        decoded_internal_cert = base64.b64decode(internal_cert).decode('utf-8')
        decoded_internal_key = base64.b64decode(internal_key).decode('utf-8')

        with open("internal.crt", "w") as f:
            f.write(decoded_internal_cert)
        with open("internal.key", "w") as f:
            f.write(decoded_internal_key)
        client_cert = ("internal.crt", "internal.key")
        
        with open("internal.crt", "r") as f:
            cert_content = f.read()
            logger.info("Contents of cert:")
            logger.info(cert_content)
        with open("internal.key", "r") as f:
            cert_content = f.read()
            logger.info("Contents of cert:")
            logger.info(cert_content)
        return client_cert

    def test_generate_api_key_for_new_added_user(client_cert, manage_host_ca_filepath):
        #user_id="maxadmin"
        global user_api_key
        user_id=manage_user
        api_key = get_api_key(user_id, client_cert, session, manage_host_ca_filepath)
        if api_key is None:
            url = MANAGE_URL + '/maximo/api/os/mxapiapikey?ccm=1&lean=1'
            logger.info("generate_api_key_URL: " + url)
            logger.info("generate_api_key_CERT" + str(client_cert))
            resp = ""
            try:
                # resp=requests.post(url , data ={'expiration':'-1', 'user_id': user_id}, cert=client_cert, verify=manage_host_ca_filepath)
                headers = {'content-type': 'application/json'}
                payload = {'expiration': '-1', 'userid': user_id}
                resp = session.post(url, headers=headers,
                                    json=payload, cert=client_cert, timeout=600, verify=manage_host_ca_filepath)
                if resp.status_code <= 201:
                    api_key = get_api_key(user_id, client_cert, session, manage_host_ca_filepath)
                    logger.info(f"GENERATED MXAPIKEY for {user_id} is: " + api_key)
                    user_api_key = api_key
                    return api_key
                else:
                    logger.info("Failed to Create APIKEY: " + user_id)
                    logger.info(resp.status_code)
                    logger.info(resp.text)
                    return None

            except Exception as ex:
                logger.info("Something wrong here")
                logger.info(ex)
        else:
            logger.info(f"RETRIEVED MXAPIKEY for {user_id} is: " + api_key)
            user_api_key = api_key
            return api_key
        
    def test_get_api_key_for_admin(client_cert, manage_host_ca_filepath):
        global admin_api_key
        api_key = get_api_key(user_id, client_cert, session, manage_host_ca_filepath)
        if api_key is None:
            url = MANAGE_URL + '/maximo/api/os/mxapiapikey?ccm=1&lean=1'
            logger.info("generate_api_key_URL: " + url)
            logger.info("generate_api_key_CERT" + str(client_cert))
            resp = ""
            try:
                # resp=requests.post(url , data ={'expiration':'-1', 'user_id': user_id}, cert=client_cert, verify=manage_host_ca_filepath)
                headers = {'content-type': 'application/json'}
                payload = {'expiration': '-1', 'userid': user_id}
                resp = session.post(url, headers=headers,
                                    json=payload, cert=client_cert, timeout=600, verify=manage_host_ca_filepath)
                if resp.status_code <= 201:
                    api_key = get_api_key(user_id, client_cert, session, manage_host_ca_filepath)
                    logger.info(f"GENERATED MXAPIKEY for {user_id} is: " + api_key)
                    admin_api_key = api_key
                    return api_key
                else:
                    logger.info("Failed to Create APIKEY: " + user_id)
                    logger.info(resp.status_code)
                    logger.info(resp.text)
                    return None

            except Exception as ex:
                logger.info("Something wrong here")
                logger.info(ex)
        else:
            logger.info(f"RETRIVED MXAPIKEY for {user_id} is: " + api_key)
            admin_api_key = api_key
            return api_key


    def get_api_key(user_id, client_cert, session, manage_host_ca_filepath):
        api_key = None
        try:
            get_api_key_url=f'''{MANAGE_URL}/maximo/api/os/mxapiapikey?lean=1&ccm=1&oslc.select=*&oslc.where=userid%3D%22{user_id}%22'''
            logger.info("get APIKEY URL: " + get_api_key_url)
            resp = session.get(get_api_key_url, cert=client_cert, timeout=600, verify=manage_host_ca_filepath)
            if resp.status_code == 200:
                data = resp.json()
                api_key = data['member'][0]['apikey']
            else:
                logger.info("Failed to Get APIKEY for: " + user_id)
                logger.info(resp.status_code)
                logger.info(resp.text)
        except Exception as ex:
            logger.info(ex)
        return api_key

    def test_add_new_user_to_admin_group(manage_host_ca_filepath):
        groupid = get_group_id(user_id, session, manage_host_ca_filepath)
        user_group_url=f'''{MANAGE_URL}/maximo/api/os/mxapigroup/{groupid}?lean=1'''

        payload = {
            "groupuser": [
                {
                    "userid": f"{manage_user}"
                }
            ]
        }
        headers = {
            "Content-Type": "application/json",
            "x-method-override": "PATCH",
            "patchtype": "MERGE",
            "apikey": admin_api_key
        }
        response = session.post(user_group_url, json=payload, headers=headers, verify=manage_host_ca_filepath)
        assert_that(response.status_code).is_equal_to(204)

    def get_group_id(user_id, session, manage_host_ca_filepath):
        group_url = f'''{MANAGE_URL}/maximo/api/os/mxapigroup?lean=1&oslc.select=*&oslc.where=groupname%3D%22{user_id}%22'''
        headers = {
            "Content-Type": "application/json",
            "apikey": admin_api_key
        }
        response = session.get(group_url, headers=headers, verify=manage_host_ca_filepath)
        if response.status_code == 200:
            data = response.json()
            group_id = data['member'][0]['maxgroupid']
            return group_id
        

    ###ASSET Object CRUD Operation using Newly created user as User is now added to maxadmin group

    def test_asset_crud_operation_using_new_added_user(manage_host_ca_filepath):
        #Check if asset exists, delete it if present
        assetid = get_asset(asset, session, manage_host_ca_filepath)
        if assetid is not None:
            logger.info("assetid not none")
            delete_asset(assetid,session, manage_host_ca_filepath)
        # Create Asset
        create_asset(asset, session, manage_host_ca_filepath)
        # Get Asset id for newly created Asset
        time.sleep(20)
        assetid = get_asset(asset, session, manage_host_ca_filepath)
        logger.info(f"ASSETID+{assetid}")
        time.sleep(20)
        # Update newly created Asset
        update_asset(assetid, session, manage_host_ca_filepath)
        # Delete newly created Asset
        delete_asset(assetid, session, manage_host_ca_filepath)
        
    def get_asset(asset, session, manage_host_ca_filepath):
        asset_url = f'''{MANAGE_URL}/maximo/api/os/mxapiasset?lean=1&oslc.select=assetnum&oslc.where=assetnum%3D%22{asset}%22'''
        headers = {
            "Content-Type": "application/json",
            "apikey": user_api_key
        }
        response = session.get(asset_url, headers=headers, verify=manage_host_ca_filepath)
        assert_that(response.status_code).is_equal_to(200)
        
        # Check if the member array is empty
        asset_member = response.json().get('member')
        if asset_member:
            asset_url = asset_member[0]['href']
            asset_id = asset_url.rsplit("mxapiasset/", 1)[-1]
            return asset_id
        else:
            # Asset does not exist
            return None

    def create_asset(asset, session, manage_host_ca_filepath):
        asset_url = f'''{MANAGE_URL}/maximo/api/os/mxapiasset?lean=1'''
        payload = {
            "_action": "AddChange",
            "assetnum": f"{asset}",
            "description": "Sanity Test Asset",
            "priority": "1",
            "siteid": "BEDFORD"
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": user_api_key
        }
        response = session.post(asset_url, json=payload, headers=headers, verify=manage_host_ca_filepath)
        assert_that(response.status_code).is_equal_to(201)

    def update_asset(assetid, session, manage_host_ca_filepath):
        asset_url = MANAGE_URL+"/maximo/api/os/mxapiasset/"+assetid
        payload = {
            "_action": "AddChange",
            "priority": "2"
        }
        querystring = {"lean":"1"}
        headers = {
            "Content-Type": "application/json",
            "x-method-override": "PATCH",
            "patchtype": "MERGE",
            "apikey": user_api_key
        }
        response = session.post(asset_url, json=payload, headers=headers, params=querystring, verify=manage_host_ca_filepath)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(204)

    def delete_asset(assetid, session, manage_host_ca_filepath):
        asset_url = MANAGE_URL+"/maximo/api/os/mxapiasset/"+assetid
        querystring = {"lean":"1"}
        headers = {
            "Content-Type": "application/json",
            "x-method-override": "PATCH",
            "patchtype": "MERGE",
            "apikey": user_api_key
        }
        response = session.delete(asset_url, headers=headers, params=querystring, verify=manage_host_ca_filepath)
        assert_that(response.status_code).is_equal_to(204)


---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $record_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "604"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
  labels:
    type: mas-app-sanity-record
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  mas_app: "manage"
  mas_catalog_version: "{{ .Values.mas_catalog_version }}"
  test_passed: "unknown"

---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $job_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "605"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  template:
    metadata:
      labels:
        app: {{ $job_name }}
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 8 }}
{{- end }}
    spec:
      imagePullSecrets: []
      containers:
        - name: run
          image: quay.io/ibmmas/cli:latest
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 200m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 64Mi
          env:
            - name: MAS_INSTANCE_ID
              value: "{{ .Values.instance_id }}"
            - name: MAS_WORKSPACE_ID
              value: "{{ .Values.mas_workspace_id }}"
            - name: MANAGE_NAMESPACE
              value: "{{ .Values.mas_app_namespace }}"
            - name: MAS_NAMESPACE
              value: "mas-{{ .Values.instance_id }}-core"
            - name: TEST_RECORD_CM
              value: "{{ $record_cm_name }}"
          volumeMounts:
            - name: tests
              mountPath: /tmp/tests
          command:
            - /bin/sh
            - -c
            - |
              python -m venv .venv
              source .venv/bin/activate
              pip install -r /tmp/tests/requirements.txt

              set -o pipefail
              echo "Running tests..."
              pytest -v --junit-xml=junitxml_test_output.xml -o cache_dir=/tmp/__pycache__ /tmp/tests/tests.py 2>&1 | tee test_log.txt
              if [[ $? -ne 0 ]]; then
                  TEST_PASSED=false
              else
                  TEST_PASSED=true
              fi
              echo "Test Result Passed: $TEST_PASSED"
              set +o pipefail

              set -e
              echo "Updating $TEST_RECORD_CM configmap with test result"
              oc set data cm $TEST_RECORD_CM test_passed=$TEST_PASSED
              oc set data cm $TEST_RECORD_CM --from-file=junitxml_test_output.xml
              oc set data cm $TEST_RECORD_CM --from-file=test_log.txt
              
              if [[ $TEST_PASSED == "false" ]]; then
                echo "Test Result failed, exit 1"
                exit 1
              fi

      restartPolicy: Never
      serviceAccountName: {{ $sa_name }}
      volumes:
        - name: tests
          configMap:
            name: {{ $tests_cm_name }}
            items:
              - key: requirements.txt
                path: requirements.txt
              - key: tests.py
                path: tests.py
            defaultMode: 420
            optional: false
  backoffLimit: 10

{{- end }}
