{{- if and (eq .Values.mas_app_id "manage") (.Values.run_sanity_test) }}

# A sanity test is one that can be disruptive i.e. it can create new users, call authenticated apis, creates resources 
# in the application. This type of test should only be run in a downstream environment such as a dev or staging env
# The control over if these tests run or not is controlled by the `run_sanity_test` boolean in the values

{{ $ns               :=  .Values.mas_app_namespace }}
{{ $np_name          :=  "postsync-sanity-manage-np" }}
{{ $role_name        :=  "postsync-sanity-manage-role" }}
{{ $crole_name       :=  "postsync-verify-manage-crole" }}
{{ $sa_name          :=  "postsync-sanity-manage-sa" }}
{{ $rb_name          :=  "postsync-sanity-manage-rb" }}
{{ $crb_name         :=  "postsync-verify-manage-crb" }}
{{ $tests_cm_name    :=  "postsync-sanity-tests-manage-cm" }}
{{ $record_cm_name   :=  "postsync-sanity-tests-manage-record-cm" }}
{{ $job_name         :=  "postsync-sanity-manage-job" }}



---
# Permit outbound communication by the Job pod
# (Needed to communicate with the K8S HTTP API, PyPI, manage Route)
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: {{ $np_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  podSelector:
    matchLabels:
      app: {{ $job_name }}
  egress:
    - {}
  policyTypes:
    - Egress


---
kind: ServiceAccount
apiVersion: v1
metadata:
  name: {{ $sa_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}



---
# -------------------------------------
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $role_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
  - verbs:
      - get
      - list
    apiGroups:
      - "apps.mas.ibm.com"
      - "route.openshift.io"
      - "config.mas.ibm.com"
      - "core.mas.ibm.com"
      - ""
    resources:
      - manageworkspace
      - manageapp
      - manageworkspaces
      - manageapps
      - secrets
      - routes
      - suites
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $rb_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "601"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: {{ $sa_name }}
    namespace: {{ $ns }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $role_name }}
# -------------------------------------

---
# -------------------------------------
# MVI Verification tests need to be able to get/list nodes
# to check for ready GPU nodes
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $crole_name }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
  - verbs:
      - get
      - list
    apiGroups:
      - ""
    resources:
      - nodes

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $crb_name }}
  annotations:
    argocd.argoproj.io/sync-wave: "601"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: {{ $sa_name }}
    namespace: {{ $ns }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: {{ $crole_name }}
# -------------------------------------

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $tests_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "602"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  requirements.txt: |-
    pytest
    kubernetes
    openshift
    ibm_db==3.2.3
    requests==2.31.0
    assertpy==1.1
  tests.py: |-
    from kubernetes import client,config
    from kubernetes.client import Configuration
    from openshift.dynamic import DynamicClient
    import pytest
    import os
    import ibm_db
    import requests
    import random
    import json
    import logging
    import base64
    from assertpy import assert_that
    from pathlib import Path
    from urllib.parse import urlparse
    logger = logging.getLogger()
    apikey=""
    siteid=""
    currency=""
    orgid=""
    setid=""
    csetid=""
    currobject=""
    MANAGE_URL = ""
    MAS_ADMIN_USERNAME = "" 
    MAS_ADMIN_PASSWORD = ""
    MANAGE_JDBC_URL = "" 
    MANAGE_JDBC_USERNAME = "" 
    MANAGE_JDBC_PASSWORD = ""
    MANAGE_JDBC_DRIVER = ""
    MANAGE_JDBC_SCHEMA = ""
    MANAGE_JDBC_CERT = ""
    nextval = ""
    schema = ""

    mas_instance_id = os.getenv("MAS_INSTANCE_ID")
    if mas_instance_id is None:
        raise Exception(f"Required MAS_INSTANCE_ID environment variable is not set")

    # e.g. "masdev"
    mas_workspace_id = os.getenv("MAS_WORKSPACE_ID")
    if mas_workspace_id is None:
        raise Exception(f"Required MAS_WORKSPACE_ID environment variable is not set")

    manageNamespace = f"mas-{mas_instance_id}-manage"
    masNamespace = f"mas-{mas_instance_id}-core"
    manage_route_name = f"{mas_instance_id}-{mas_workspace_id}"

    @pytest.fixture(scope="session")
    def dyn_client():
        if "KUBERNETES_SERVICE_HOST" in os.environ:
            config.load_incluster_config()
            k8s_config = Configuration.get_default_copy()
            k8s_client = client.ApiClient(configuration=k8s_config)
        else:
            k8s_client = config.new_client_from_config()

        dyn_client = DynamicClient(k8s_client)
        dyn_client.namespace = manageNamespace
        yield dyn_client

    @pytest.fixture(scope="session")
    def dyn_client_mas_core():
        if "KUBERNETES_SERVICE_HOST" in os.environ:
            config.load_incluster_config()
            k8s_config = Configuration.get_default_copy()
            k8s_client = client.ApiClient(configuration=k8s_config)
        else:
            k8s_client = config.new_client_from_config()

        dyn_client = DynamicClient(k8s_client)
        dyn_client.namespace = masNamespace
        yield dyn_client

    @pytest.fixture(scope="session")
    def v1_manageworkspace(dyn_client):
        yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')

    @pytest.fixture(scope="session")
    def v1_manageapp(dyn_client):
        yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageApp')

    @pytest.fixture(scope="session")
    def mange_workspace_reconciled_version(mange_workspace_cr):
        try:
            yield mange_workspace_cr['status']['versions']['reconciled']
        except KeyError as e:
            assert False, f"Unable to determine ManageWorkspace reconciled version. Error details: {e}"

    @pytest.fixture(scope="session")
    def manage_version(mange_app_cr):
        try:
            yield mange_app_cr['status']['components']['manage']['version']
        except KeyError as e:
            assert False, f"Unable to determine ManageApp component version. Error details: {e}"

    @pytest.fixture(scope="session")
    def mange_workspace_cr(v1_manageworkspace):
        yield v1_manageworkspace.get(namespace=manageNamespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}, mas.ibm.com/workspaceId={mas_workspace_id}").items[0]

    @pytest.fixture(scope="session")
    def mange_app_cr(v1_manageapp):
        yield v1_manageapp.get(namespace=manageNamespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}").items[0]

    @pytest.fixture(scope="session")
    def v1_secrets(dyn_client):
        yield dyn_client.resources.get(api_version='v1', kind='Secret')

    @pytest.fixture(scope="session")
    def v1_routes(dyn_client):
        yield dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')

    @pytest.fixture(scope="session")
    def manage_route(v1_routes):
        yield v1_routes.get(name=manage_route_name, namespace=manageNamespace)

    @pytest.fixture(scope="session")
    def manage_host(manage_route):
        try:
            yield manage_route['spec']['host']
        except KeyError as e:
            assert False, f"Unable to determine Manage host; spec.host key not present in {manage_route_name}/{manageNamespace}: {manage_route}. Error details: {e}"

    # Obtain Manage Details
    def test_getManageComponents(dyn_client):
        instanceId = os.getenv("MAS_INSTANCE_ID")
        workspaceId = os.getenv("MAS_WORKSPACE_ID")
        manageNamespace = f"mas-{instanceId}-manage"
        manageWorkspaces = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
        try:
            manageWorkspaceInstance = manageWorkspaces.get(name=f'{instanceId}-{workspaceId}', namespace=manageNamespace)
        except Exception:
            logger.info(f'ApiException: Failed to retrieve {instanceId}-{workspaceId} instance of ManageWorkspace in namespace {manageNamespace}')
        manageComponentListInStr = ",".join(list(manageWorkspaceInstance['spec']['components'].keys()))
        logger.info(f'{manageComponentListInStr}') # like this: base,health,nuclear

    def test_getClusterInfo(dyn_client,dyn_client_mas_core):
        # -------------------------------
        # Environment Variables Setup
        # -------------------------------
        instanceId = os.getenv("MAS_INSTANCE_ID")
        workspaceId = os.getenv("MAS_WORKSPACE_ID")
        masNamespace = f"mas-{instanceId}-core"
        manageNamespace = f"mas-{instanceId}-manage"

        # Manage Workspace and Credentials
        manageDBCredential = f'jdbc-mas-{instanceId}-{workspaceId}-manage-credentials'
        manageWorkspaceCR = None

        # -------------------------------
        # Manage Workspace CR
        # -------------------------------
        try:
            manageWorkspaceCRD = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
            manageWorkspaceCR = manageWorkspaceCRD.get(name=f'{instanceId}-{workspaceId}', namespace=manageNamespace)
        except Exception as ex:
            logger.info(f"######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")

        # -------------------------------
        # Manage Deployment DB Info
        # -------------------------------
        try:
            manageDeployments = dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageDeployment')
            manageDeploymentInstance = manageDeployments.get(name='manage-maxinst', namespace=manageNamespace)
            dbDriver = manageDeploymentInstance['spec']['db']['maximoDBdriver']
            dbSchema = manageDeploymentInstance['spec']['db']['maximoDBschema']
        except Exception as ex:
            logger.info(f"ApiException: Failed to retrieve manage-maxinst instance in namespace {manageNamespace}: {str(ex)}")

        # -------------------------------
        # Manage URL (OpenShift Route)
        # -------------------------------
        try:
            manageRouteObject = dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')
            manageRouteDetails = manageRouteObject.get(name=f'{instanceId}-manage-{workspaceId}', namespace=manageNamespace)
            manageUrl = manageRouteDetails.spec.host
        except Exception as e:
            if e.status == 404:
                logger.info(f"Unable to find route {instanceId}-manage-{workspaceId} in {manageNamespace}")
            else:
                logger.info(f"Error retrieving route: {str(e)}")

        global MAS_ADMIN_USERNAME, MAS_ADMIN_PASSWORD, MANAGE_URL
        if manageUrl:
            MANAGE_URL = f"https://{manageUrl}/maximo"
        global MANAGE_JDBC_URL, MANAGE_JDBC_USERNAME, MANAGE_JDBC_PASSWORD, MANAGE_JDBC_DRIVER, MANAGE_JDBC_SCHEMA, MANAGE_JDBC_CERT

        # -------------------------------
        # Obtain Superuser credentials
        # -------------------------------
        secrets = dyn_client_mas_core.resources.get(api_version='v1', kind='Secret')
        superuserCredentials = secrets.get(instanceId+'-credentials-superuser', masNamespace)
        MAS_ADMIN_USERNAME = superuserCredentials.data.username
        MAS_ADMIN_PASSWORD = superuserCredentials.data.password
        # -------------------------------
        # JDBC Credentials
        # -------------------------------
        try:
            jdbcCfgObj = dyn_client_mas_core.resources.get(api_version='config.mas.ibm.com/v1', kind='JdbcCfg')
            #jdbcCfgDetails = jdbcCfgObj.get(name=f'{instanceId}-manage-{workspaceId}', namespace=masNamespace)
            bindingManage = manageWorkspaceCR.spec.bindings.jdbc
        except Exception as ex:
            logger.info(f"######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")
        logger.info(f"ManageWorkspace has jdbc binding set to {bindingManage}")

        if "system" in bindingManage:
            jdbcCfgInstName = f'{instanceId}-jdbc-system'
        elif "workspace-application" in bindingManage:
            jdbcCfgInstName = f'{instanceId}-jdbc-wsapp-{workspaceId}-manage'
        else:
            logger.info("######### WARN: Unknown jdbc binding found in ManageWorkspace")

        try:
            jdbcCfg = jdbcCfgObj.get(name=jdbcCfgInstName, namespace=masNamespace)
            credentialsSecret = jdbcCfg.spec.config.credentials.secretName
            secrets = dyn_client_mas_core.resources.get(api_version='v1', kind='Secret')
            credentials = secrets.get(name=credentialsSecret, namespace=masNamespace)
        except Exception:
            logger.info("ApiException: Failed to retrieve Manage database details. Check ManageWorkspace jdbc binding spec")

        # -------------------------------
        # Database Certificate
        # -------------------------------
        if jdbcCfg is not None:
            try:
                with open('db2-tls.cert', 'w') as f:
                    f.write(jdbcCfg.spec.certificates[0].crt)
            except Exception as e:
                logger.info(f"Error writing certificate: {str(e)}")
        else:
            logger.info("JdbcCfg was not assigned. Skipping certificate writing.")

        MANAGE_JDBC_URL = jdbcCfg.spec.config.url if jdbcCfg else None
        MANAGE_JDBC_USERNAME = credentials.data.username
        MANAGE_JDBC_PASSWORD = credentials.data.password
        MANAGE_JDBC_DRIVER = dbDriver
        MANAGE_JDBC_SCHEMA = dbSchema
        MANAGE_JDBC_CERT = "./db2-tls.cert"

        print(MANAGE_JDBC_URL)
        print(MANAGE_JDBC_USERNAME)
        print(MANAGE_JDBC_PASSWORD)
        print(MANAGE_URL)
        print(MAS_ADMIN_USERNAME)
        print(MAS_ADMIN_PASSWORD)
        print(MANAGE_JDBC_DRIVER)
        print(MANAGE_JDBC_SCHEMA)
        print(MANAGE_JDBC_CERT)

    def test_manage_db_connection_and_update_permissions():

        url = MANAGE_JDBC_URL.replace("jdbc:", "") if MANAGE_JDBC_URL is not None else None
        jdbc_details = urlparse(url)
        
        db_config = {
            "database": jdbc_details.path.replace("/", "").split(":")[0],
            "hostname": jdbc_details.hostname,
            "port": jdbc_details.port,
            "protocol": "TCPIP",
            "user": globals().get('MANAGE_JDBC_USERNAME'),
            "password": globals().get('MANAGE_JDBC_PASSWORD'),
            "cert": globals().get('MANAGE_JDBC_CERT'),
            "driver": globals().get('MANAGE_JDBC_DRIVER')
        }

        # Check DB2 database and validate certificate
        if "DB2" in db_config["driver"]:
            logger.info("=== DB2 Database -- Setting up connection ===")

            # Certificate validation
            cert_path = db_config["cert"]
            valid_cert = cert_path and Path(cert_path).exists() and any("CERTIFICATE" in line for line in open(cert_path))
            if cert_path:
                logger.info(f"Certificate location: {cert_path}")
            
            # Create connection string
            conn_str = (
                f"DATABASE={db_config['database']};HOSTNAME={db_config['hostname']};PORT={db_config['port']};"
                f"PROTOCOL={db_config['protocol']};UID={db_config['user']};PWD={db_config['password']};"
                + (f"SECURITY=SSL;SSLServerCertificate={db_config['cert']};" if valid_cert else "")
            )
            connection = ibm_db.connect(conn_str, "", "")
            logger.info("Connection established successfully.")
            
            try:
                # Manage permissions
                schema = "" if "dbo" in MANAGE_JDBC_SCHEMA else (MANAGE_JDBC_SCHEMA + ".")
                nextval = "NEXT VALUE" if "dbo" in MANAGE_JDBC_SCHEMA else "NEXTVAL"

                os_query = (
                    f"SELECT app FROM {schema}applicationauth WHERE app IN "
                    f"('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET','MXEXTSYSTEM','INTOBJECT','MXAPIINTOBJECT','MXAPIMAXAPP','MXAPIPERUSER') "
                    f"AND groupname='MAXADMIN';"
                )
                
                result_set = fetch_both(connection, os_query)

                if result_set:
                    logger.info("Object structures already present: %s", result_set)
                    update_permissions(connection, 'MXAPIPERSONGROUP', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'MXAPIPROP', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'MXAPIGROUP', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'MXASSET', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'MXEXTSYSTEM', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'INTOBJECT', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'MXAPIINTOBJECT', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'MXAPIMAXAPP', 'MAXADMIN', schema, nextval)
                    update_permissions(connection, 'MXAPIPERUSER', 'MAXADMIN', schema, nextval)
                else:
                    logger.info("No required object structure found. Updating MAXADMIN group.")
                    update_query = (
                        f"INSERT INTO {schema}applicationauth (groupname, app, optionname, applicationauthid) "
                        f"SELECT 'MAXADMIN', app, optionname, {nextval} FROM {schema}sigoption WHERE app IN "
                        f"('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET','MXEXTSYSTEM','INTOBJECT','MXAPIINTOBJECT','MXAPIMAXAPP','MXAPIPERUSER');"
                    )
                    execute_query(connection, update_query)
                    logger.info("Permissions successfully granted to MAXADMIN.")
            finally:
                ibm_db.close(connection)
                logger.info("Connection closed.")

    def fetch_both(connection, stmt):
        response = ibm_db.exec_immediate(connection, stmt)
        return ibm_db.fetch_both(response)

    def execute_query(connection, stmt):
        ibm_db.exec_immediate(connection, stmt)

    def update_permissions(connection, application, group, schema, nextval):
        # Check if permission is already present
        select_query = f"SELECT app FROM {schema}applicationauth WHERE app = '{application}' AND groupname = '{group}';"
        result_set = fetch_both(connection, select_query)

        if result_set:
            logger.info(f"Permissions for {application} already present. Reapplying permissions.")
            delete_query = f"DELETE FROM {schema}applicationauth WHERE app = '{application}' AND groupname = '{group}';"
            execute_query(connection, delete_query)

        # new permissions
        update_query = (
            f"INSERT INTO {schema}applicationauth (groupname, app, optionname, applicationauthid) "
            f"SELECT '{group}', app, optionname, {nextval} FROM {schema}sigoption WHERE app = '{application}';"
        )
        execute_query(connection, update_query)
        logger.info(f"Permissions for {application} applied successfully.")

    def test_generatekey():
        global apikey
        maxauth=str(MAS_ADMIN_USERNAME+":"+MAS_ADMIN_PASSWORD)
        base64_maxauth = base64.b64encode(maxauth.encode("utf-8"))
        maxauth = base64_maxauth.decode("utf-8")
        url = MANAGE_URL+"/api/apitoken/create"
        payload = {"expiration": -1}
        headers = {
            "Content-Type": "application/json",
            "maxauth":maxauth
        }
        response = requests.request("POST", url, json=payload, headers=headers).json()
        apikey=response['apikey']
        
    def test_create_user():
        url = MANAGE_URL+"/api/os/mxapiperuser"
        querystring = {"lean":"1"}
        personid="person"+str(random.randint(0,100))
        payload = {
            "personid": personid,
            "firstname": "first"+str(random.randint(0,100)),
            "lastname": "last"+str(random.randint(0,100)),
            "primaryemail": personid+"@yahoo.com",
            "primaryphone": "999 999 9999",
            "city": "Boston",
            "addressline1": "23 wabashs street",
            "stateprovince": "MA",
            "postalcode": "01111",
            "country": "US",
            "language": "EN",
            "maxuser": [
                {
                    "loginid": personid,
                    "passwordcheck": personid,
                    "passwordinput": personid,
                    "defsite": "BEDFORD",
                    "type": "TYPE 1",
                    "userid": personid
                }
            ]
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)

    def test_generateObjectStructureforCurrency():
        url = MANAGE_URL+"/api/os/mxintobject"
        global currobject
        querystring = {"lean":"1"}
        currobject="MXCUR"+str(random.randint(0,100))
        payload = {
            "intobjectname": currobject,
            "description": "API Automation - "+currobject,
            "usewith": "INTEGRATION",
            "authapp": "MXAPIINTOBJECT",
            "maxintobjdetail": {"objectname": "CURRENCY"}
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)

    def test_create_currency():
        global currency
        currency="curr"+str(random.randint(0,100))
        logger.info(currency)

        url = MANAGE_URL+"/api/os/"+currobject

        querystring = {"lean":"1"}

        payload = {
            "currencycode": currency,
            "description": currency+" Description"
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_create_item_set():
        url = MANAGE_URL+"/api/os/mxapisets"
        global setid
        setid="itset"+str(random.randint(5,100))

        querystring = {"lean":"1"}

        payload = {
            "settype_description": "Item Sets",
            "settype": "ITEM",
            "setid": setid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(201)
        
    def test_create_company_set():
        url = MANAGE_URL+"/api/os/mxapisets"
        global csetid
        csetid="comset"+str(random.randint(5,100))
        querystring = {"lean":"1"}
        payload = {
            "settype_description": "Item Sets",
            "settype": "COMPANY",
            "setid": csetid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        
    def test_create_org():
        url = MANAGE_URL+"/api/os/mxapiorganization"
        global siteid,orgid
        querystring = {"lean":["1","1"]}
        orgid="org"+str(random.randint(0,1000))
        logger.info(orgid)
        
        payload = {
            "active": False,
            "dfltitemstatus_description": "Active",
            "orgid": orgid,
            "basecurrency1": currency,
            "companysetid": csetid,
            "organizationid": 7,
            "description": "MY ORG IN GUJARAT",
            "dfltitemstatus": "ACTIVE",
            "itemsetid": setid,
            "category": "NS"
        }
        headers = {
            
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlCompany():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (111)",
            "glorder": 0,
            "active": True,
            "compvalue": 111,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlCompany2():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (222)",
            "glorder": 1,
            "active": True,
            "compvalue": 222,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlCompany3():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (333)",
            "glorder": 2,
            "active": True,
            "compvalue": 333,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        logger.info(response.text)

    def test_createGlAccount():
        url = MANAGE_URL+"/api/os/MXAPICOA"

        querystring = {"lean":"1"}

        payload = {
            "glaccount": "111-222-333",
            "accountname": "111-222-333",
            "active": True,
            "glcomp01": "111",
            "glcomp02": "222",
            "glcomp03": "333",
            "orgid": orgid
        }
        headers = {
            
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)

        logger.info(response.text)
        assert_that(response.status_code).is_equal_to(requests.codes.created)

    def test_updateOrgToActiveSiteAndGL():
        url = MANAGE_URL+"/api/os/mxapiorganization"
        global siteid
        orgid2= "orgid=\""+orgid+"\""
        logger.info(orgid2)
        querystring = {"lean":["1","1"],"oslc.select":"*","oslc.where":orgid2}
        logger.info(querystring)

        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("GET", url, headers=headers, params=querystring)
        logger.info("response")
        jsonresponse=response.json()

        logger.info(jsonresponse['member'][0]['organizationid'])
        orgid3=jsonresponse['member'][0]['organizationid']

        url = MANAGE_URL+"/api/os/mxapiorganization/"+str(orgid3)
        siteid="site"+str(random.randint(0,100))
        logger.info(siteid)
        querystring = {"lean":["1","1"]}

        payload = {
            "site": [
                {
                    "description_longdescription": "Automation Site 1",
                    "active": True,
                    "description": "Automation Site 1",
                    "siteid": siteid
                }
            ],
            "clearingacct": "111-222-333",
            "active": True
        }
        headers = {
        
            "Content-Type": "application/json",
            "x-method-override": "PATCH",
            "patchtype": "MERGE",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(204)

---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $job_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "604"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  template:
    metadata:
      labels:
        app: {{ $job_name }}
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 8 }}
{{- end }}
    spec:
      imagePullSecrets: []
      containers:
        - name: run
          image: quay.io/ibmmas/cli:latest
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 200m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 64Mi
          env:
            - name: MAS_INSTANCE_ID
              value: "{{ .Values.instance_id }}"
            - name: MAS_WORKSPACE_ID
              value: "{{ .Values.mas_workspace_id }}"
            - name: MANAGE_NAMESPACE
              value: "{{ .Values.mas_app_namespace }}"
            - name: MAS_NAMESPACE
              value: "mas-{{ .Values.instance_id }}-core"
          volumeMounts:
            - name: tests
              mountPath: /tmp/tests
          command:
            - /bin/sh
            - -c
            - |
              python -m venv .venv
              source .venv/bin/activate
              pip install -r /tmp/tests/requirements.txt
              pytest -o cache_dir=/tmp/__pycache__ /tmp/tests/tests.py 
      restartPolicy: Never
      serviceAccountName: {{ $sa_name }}
      volumes:
        - name: tests
          configMap:
            name: {{ $tests_cm_name }}
            items:
              - key: requirements.txt
                path: requirements.txt
              - key: tests.py
                path: tests.py
            defaultMode: 420
            optional: false
  backoffLimit: 4

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $record_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "605"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
  labels:
    type: mas-app-verification-record
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  mas_app: "manage"
  mas_catalog_version: "{{ .Values.mas_catalog_version }}"

{{- end }}
