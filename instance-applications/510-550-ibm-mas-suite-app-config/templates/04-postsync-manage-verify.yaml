{{- if eq .Values.mas_app_id "manage" }}

# A verify test is one that is non disruptive i.e. it won't create new users, i won't call authenticated apis, and it won't creates resources 
# in the application. This type of test is run on every environment and allows a layer of verification of the app

{{ $ns               :=  .Values.mas_app_namespace }}
{{ $np_name          :=  "postsync-verify-manage-np" }}
{{ $role_name        :=  "postsync-verify-manage-role" }}
{{ $sa_name          :=  "postsync-verify-manage-sa" }}
{{ $rb_name          :=  "postsync-verify-manage-rb" }}
{{ $tests_cm_name    :=  "postsync-verify-tests-manage-cm" }}
{{ $record_cm_name   :=  "postsync-verify-tests-manage-record-cm" }}
{{ $job_name         :=  "postsync-verify-manage-job" }}



---
# Permit outbound communication by the Job pod
# (Needed to communicate with the K8S HTTP API, PyPI, manage Route)
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: {{ $np_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  podSelector:
    matchLabels:
      app: {{ $job_name }}
  egress:
    - {}
  policyTypes:
    - Egress


---
kind: ServiceAccount
apiVersion: v1
metadata:
  name: {{ $sa_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}



---
# -------------------------------------
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $role_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
  - verbs:
      - get
      - list
    apiGroups:
      - "apps.mas.ibm.com"
    resources:
      - manageworkspace
      - manageapp
      - manageworkspaces
      - manageapps
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $rb_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "601"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: {{ $sa_name }}
    namespace: {{ $ns }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $role_name }}
# -------------------------------------


---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $tests_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "602"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  requirements.txt: |-
    pytest
    kubernetes
    openshift
  tests.py: |-
    from kubernetes import client,config
    from kubernetes.client import Configuration
    from openshift.dynamic import DynamicClient
    import pytest
    import os
    import ibm_db
    import requests
    import random
    import json
    import base64
    from assertpy import assert_that

    apikey=""
    siteid=""
    currency=""
    orgid=""
    setid=""
    csetid=""
    currobject=""
    MANAGE_URL = ""
    MAS_ADMIN_USERNAME = "" 
    MAS_ADMIN_PASSWORD = ""

    mas_instance_id = os.getenv("MAS_INSTANCE_ID")
    if mas_instance_id is None:
      raise Exception(f"Required MAS_INSTANCE_ID environment variable is not set")

    # e.g. "masdev"
    mas_workspace_id = os.getenv("MAS_WORKSPACE_ID")
    if mas_workspace_id is None:
      raise Exception(f"Required MAS_WORKSPACE_ID environment variable is not set")

    manage_namespace = f"mas-{mas_instance_id}-manage"
    manage_route_name = f"{mas_instance_id}-{mas_workspace_id}"

    @pytest.fixture(scope="session")
    def dyn_client():
      if "KUBERNETES_SERVICE_HOST" in os.environ:
        config.load_incluster_config()
        k8s_config = Configuration.get_default_copy()
        k8s_client = client.api_client.ApiClient(configuration=k8s_config)
      else:
        k8s_client = config.new_client_from_config()
      dyn_client = DynamicClient(k8s_client)
      yield dyn_client

    @pytest.fixture(scope="session")
    def v1_manageworkspace(dyn_client):
      yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')

    @pytest.fixture(scope="session")
    def v1_manageapp(dyn_client):
      yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageApp')

    @pytest.fixture(scope="session")
    def mange_workspace_reconciled_version(mange_workspace_cr):
      try:
        yield mange_workspace_cr['status']['versions']['reconciled']
      except KeyError as e:
        assert False, f"Unable to determine ManageWorkspace reconciled version. Error details: {e}"

    @pytest.fixture(scope="session")
    def manage_version(mange_app_cr):
      try:
        yield mange_app_cr['status']['components']['manage']['version']
      except KeyError as e:
        assert False, f"Unable to determine ManageApp component version. Error details: {e}"

    @pytest.fixture(scope="session")
    def mange_workspace_cr(v1_manageworkspace):
      yield v1_manageworkspace.get(namespace=manage_namespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}, mas.ibm.com/workspaceId={mas_workspace_id}").items[0]

    @pytest.fixture(scope="session")
    def mange_app_cr(v1_manageapp):
      yield v1_manageapp.get(namespace=manage_namespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}").items[0]

    def test_expected_reconciled_version(mange_workspace_reconciled_version, manage_version):
      assert manage_version == mange_workspace_reconciled_version, f"Expected ManageWorkspace Reconciled version: {mange_workspace_reconciled_version} to match Manage Operator version: {manage_version}"

    def test_languages_set(mange_workspace_cr):
      status_langs = mange_workspace_cr['status']['settings']['languages']
      spec_langs = mange_workspace_cr['spec']['settings']['languages']
      if spec_langs is not None:
        assert status_langs == spec_langs, f"Expected languages set in the spec: {spec_langs} to be equal to the languages in the status: {status_langs}"

    def test_addons_enabled(mange_workspace_cr):
      for component in mange_workspace_cr['spec']['components']:
        print(f"check component {component[0]} in status")
        assert mange_workspace_cr['status']['components'][component[0]]["enabled"], f"Expected component {component} to be enabled in status"

    def test_bundle_sizes(mange_workspace_cr):
      spec_serverbundles = mange_workspace_cr['spec']['settings']['deployment']['serverBundles']
      status_serverbundles = mange_workspace_cr['status']['settings']['deployment']['serverBundles']
      if spec_serverbundles is not None:
        assert status_serverbundles == spec_serverbundles, f"Expected serverbundles set in the spec: {spec_serverbundles} to be equal to the languages in the status: {status_serverbundles}"

    @pytest.fixture(scope="session")
    def v1_secrets(dyn_client):
      yield dyn_client.resources.get(api_version='v1', kind='Secret')

    @pytest.fixture(scope="session")
    def v1_routes(dyn_client):
      yield dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')

    @pytest.fixture(scope="session")
    def manage_route(v1_routes):
      yield v1_routes.get(name=manage_route_name, namespace=manage_namespace)

    @pytest.fixture(scope="session")
    def manage_host(manage_route):
      try:
        yield manage_route['spec']['host']
      except KeyError as e:
        assert False, f"Unable to determine Manage host; spec.host key not present in {manage_route_name}/{manage_namespace}: {manage_route}. Error details: {e}"

    # Obtain Manage Details
    @pytest.fixture(scope="session")
    def getManageComponents():
      instanceId = os.getenv("MAS_INSTANCE_ID")
      workspaceId = os.getenv("MAS_WORKSPACE_ID")
      manage_namespace = f"mas-{mas_instance_id}-manage"
        
      k8sUtil = KubernetesUtil()
      manageWorkspaces = k8sUtil.dynClient.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
      try:
          manageWorkspaceInstance = manageWorkspaces.get(name=f'{instanceId}-{workspaceId}', namespace=manage_namespace)
      except ApiException:
          print(f'ApiException: Failed to retrieve {instanceId}-{workspaceId} instance of ManageWorkspace in namespace {manage_namespace}')
      manageComponentListInStr = ",".join(list(manageWorkspaceInstance['spec']['components'].keys()))
      print(f'{manageComponentListInStr}') # like this: base,health,nuclear

    @pytest.fixture(scope="session")
    def getClusterInfo():
      instanceId = os.getenv("MAS_INSTANCE_ID")
      workspaceId = os.getenv("MAS_WORKSPACE_ID")
      manage_namespace = f"mas-{mas_instance_id}-manage"
      manageDBCredential = f'jdbc-mas-{instanceId}-{workspaceId}-manage-credentials'

      k8sUtil = KubernetesUtil()

      # -------------------------------
      # Obtain ManageWorkspace CR
      # - Used to obtain other data bwlow
      # -------------------------------
      manageWorkspaceCR = None
      try:
          manageWorkspaceCRD = k8sUtil.dynClient.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')
          manageWorkspaceCR = manageWorkspaceCRD.get(name=f'{instanceId}-{workspaceId}', namespace=manage_namespace)
      except ApiException as ex:
          print("######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")

      # -------------------------------
      # Obtain DB Driver
      # -------------------------------

      manageDeployments = k8sUtil.dynClient.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageDeployment')
      try:
          manageDeploymentInstance = manageDeployments.get(name=f'manage-maxinst', namespace=manage_namespace)
          dbDriver = (manageDeploymentInstance['spec']['db']['maximoDBdriver'])
          dbSchema = (manageDeploymentInstance['spec']['db']['maximoDBschema'])

      except ApiException:
          print(f'ApiException: Failed to retrieve manage-maxinst instance of ManageWorkspace in namespace {manage_namespace}')   

      # -------------------------------
      # Obtain MAS URL
      # -------------------------------
      masNamespace = os.getenv("MAS_NAMESPACE")
      masRouteDetails = k8sUtil.dynClient.resources.get(api_version='route.openshift.io/v1', kind='Route')
      masUrl = masRouteDetails.get(name=f'{instanceId}-admin', namespace=masNamespace)
      masHome = masRouteDetails.get(name=f'{instanceId}-{workspaceId}-home', namespace=masNamespace)
      masDomain = masUrl.spec.host.replace('home.', '', 1)

      # -------------------------------
      # Obtain Manage URL
      # -------------------------------
      try:
          manageRouteDetails = k8sUtil.dynClient.resources.get(api_version='route.openshift.io/v1', kind='Route')
          manageUrl = masRouteDetails.get(name=f'{instanceId}-manage-{workspaceId}', namespace=manage_namespace)
      except Exception as e:
          if e.status == 404:
              print(f"Unable to find route {instanceId}-manage-{workspaceId} in {manage_namespace}")

      # -------------------------------
      # Obtain JDBC credentials
      # -------------------------------
      try:
          jdbcCfgDetails = k8sUtil.dynClient.resources.get(api_version='config.mas.ibm.com/v1', kind='JdbcCfg')
          bindingManage = manageWorkspaceCR.spec.bindings.jdbc
      except ApiException as ex:
          print("######### ApiException: ManageWorkspace is not available or was not found. Check it out: {str(ex)}")
      
      print(f"ManageWorkspace has jdbc binding set to {bindingManage}")

      if "system" in bindingManage:
          jdbcCfgInstName = f'{instanceId}-jdbc-system'
      elif "workspace-application" in bindingManage:
          jdbcCfgInstName = f'{instanceId}-jdbc-wsapp-{workspaceId}-manage'
      else:
          print("######### WARN: Unknown jdbc binding found in ManageWorkspace")

      try:
          jdbcCfg = jdbcCfgDetails.get(name=jdbcCfgInstName, namespace=masNamespace)
          credentialsSecret = jdbcCfg.spec.config.credentials.secretName
          credentials = k8sUtil.getSecret(credentialsSecret, masNamespace)
      except ApiException:
          print("ApiException: Failed to retrieve Manage database details. Check ManageWorkspace jdbc binding spec")

      # -------------------------------
      # Obtain Superuser credentials
      # -------------------------------
      superuserCredentials = k8sUtil.getSecret(instanceId+'-credentials-superuser', masNamespace)

      # -------------------------------
      # Generate the DBC cert file
      # -------------------------------
      try:
          with open('db2-tls.cert', 'w') as f:
              f.write(jdbcCfg.spec.certificates[0].crt)
      except TypeError:
          print("######### WARN: Database certificates not found")

      # -------------------------------
      # Output to be recovered by caller sh
      # -------------------------------
      
      MAS_URL=https://{masUrl.spec.host}{masUrl.spec.path}
      MAS_HOME=https://{masHome.spec.host}{masHome.spec.path}
      MAS_DOMAIN={masDomain}
      MANAGE_JDBC_URL={jdbcCfg.spec.config.url}
      MANAGE_JDBC_USERNAME={credentials.get("username")}
      MANAGE_JDBC_PASSWORD={credentials.get("password")}
      global MAS_ADMIN_USERNAME, MAS_ADMIN_PASSWORD,MANAGE_URL
      if manageUrl is not None:
          MANAGE_URL=https://{manageUrl.spec.host}{manageUrl.spec.path}maximo
      MAS_ADMIN_USERNAME={superuserCredentials.get("username")}
      MAS_ADMIN_PASSWORD={superuserCredentials.get("password")}
      MANAGE_JDBC_DRIVER={dbDriver}
      MANAGE_JDBC_SCHEMA={dbSchema}

    # Manage db configuration
    @pytest.fixture(scope="session")
    def manage_db_connection():
        import ibm_db
        url = os.getenv("MANAGE_JDBC_URL", None).replace("jdbc:", "")
        jdbcDetails = urlparse(url)

        db_config = {
            "database": jdbcDetails.path.replace("/", "").split(":")[0],
            "hostname": jdbcDetails.hostname,
            "port": jdbcDetails.port,
            "protocol": "TCPIP",
            "user": os.getenv("MANAGE_JDBC_USERNAME", None),
            "password": os.getenv("MANAGE_JDBC_PASSWORD", None),
            "cert": os.getenv("MANAGE_JDBC_CERT", None),
            "driver": os.getenv("MANAGE_JDBC_DRIVER", None),
        }
        
        # Check database type
        # -----------------------------------------------------------------------------
        # DB2 - with and without certification
        if "DB2" in db_config["driver"]:
            logger.info("=== DB2 Database -- Setting up connection ===")

            # Validate if certification is not empty
            ValidCert = False
            cert_path = os.getenv("MANAGE_JDBC_CERT")
            if cert_path is not None:
                cert_file = Path(cert_path)
                logger.info(f"Certificate location:{cert_path}")
                if cert_file.exists():
                    file = open(os.getenv("MANAGE_JDBC_CERT"), "r")
                    for line in file:
                        if re.search("CERTIFICATE", line):
                            ValidCert = True

            conn_str = (
                f"DATABASE={db_config['database']};HOSTNAME={db_config['hostname']};PORT={db_config['port']};PROTOCOL={db_config['protocol']};UID={db_config['user']};PWD={db_config['password']};"
                + (
                    f"SECURITY=SSL;SSLServerCertificate={db_config['cert']};"
                    if ValidCert
                    else f""
                )
            )
            connection = ibm_db.connect(conn_str, "", "")
            yield connection
            ibm_db.close(connection)

    @pytest.fixture(scope="session")
    def updateMaxadminGroup(manage_db_connection):
        nextval = ("NEXT VALUE" if "dbo" in os.getenv("MANAGE_JDBC_SCHEMA") else "NEXTVAL")
        schema = ("" if "dbo" in os.getenv("MANAGE_JDBC_SCHEMA") else (os.getenv("MANAGE_JDBC_SCHEMA")+"."))
        os_query = f"""select app from {schema}applicationauth
        where app in ('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET','MXEXTSYSTEM', 'INTOBJECT', 'MXAPIINTOBJECT', 'MXAPIMAXAPP','MXAPIPERUSER') 
        and groupname='MAXADMIN';
        """
        result_set = fetchBoth(manage_db_connection,os_query)
        if result_set:
            logger.info("Some object structure is already there as %s", result_set)
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIPERSONGROUP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIPROP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIGROUP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXASSET', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXEXTSYSTEM', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'INTOBJECT', 'MAXADMIN')        
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIINTOBJECT', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIMAXAPP', 'MAXADMIN')
            updateSpecificPermissionToGroup(manage_db_connection, 'MXAPIPERUSER', 'MAXADMIN')
        else:
            logger.info(
                "No required object structure is present in MAXADMIN. Hence, updating MAXADMIN group."
            )
            update_query = (
                f"""insert into {schema}applicationauth 
                (groupname, app, optionname, applicationauthid) select 'MAXADMIN', app, optionname, 
                {nextval} for {schema}applicationauthseq from {schema}sigoption where app in 
                ('MXAPIPERSONGROUP','MXAPIPROP','MXAPIGROUP','MXASSET',
                'MXEXTSYSTEM', 'INTOBJECT', 'MXAPIINTOBJECT', 'MXAPIMAXAPP','MXAPIPERUSER');"""
            )
            executeQuery(manage_db_connection, update_query)
            logger.info("Object Structure permission successfully granted to MAXADMIN")

    @pytest.fixture(scope="session")
    def test_generatekey():
        global apikey
        maxauth=str(MAS_ADMIN_USERNAME+":"+MAS_ADMIN_PASSWORD)
      
        base64_maxauth = base64.b64encode(maxauth.encode("utf-8"))
        maxauth = base64_maxauth.decode("utf-8")
        url = MANAGE_URL+"/oslc/apitoken/create"
        payload = {"expiration": -1}
        headers = {
            "Content-Type": "application/json",
            "maxauth":maxauth
        }
        response = requests.request("POST", url, json=payload, headers=headers).json()
      
        apikey=response['apikey']

    @pytest.fixture(scope="session")
    def test_generateObjectStructureforCurrency():
        url = MANAGE_URL+"/api/os/mxintobject"
        global currobject
        querystring = {"lean":"1"}
        currobject="MXCUR"+str(random.randint(0,100))
        payload = {
            "intobjectname": currobject,
            "description": "API Automation - "+currobject,
            "usewith": "INTEGRATION",
            "authapp": "MXAPIINTOBJECT",
            "maxintobjdetail": {"objectname": "CURRENCY"}
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        print(response.text)

    @pytest.fixture(scope="session")
    def test_create_currency():
        global currency
        currency="curr"+str(random.randint(0,100))
        print(currency)

        url = MANAGE_URL+"/api/os/"+currobject

        querystring = {"lean":"1"}

        payload = {
            "currencycode": currency,
            "description": currency+" Description"
        }
        headers = {

            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        print(response.text)

    @pytest.fixture(scope="session")
    def test_create_item_set():
        url = MANAGE_URL+"/api/os/mxapisets"
        global setid
        setid="itset"+str(random.randint(5,100))

        querystring = {"lean":"1"}

        payload = {
            "settype_description": "Item Sets",
            "settype": "ITEM",
            "setid": setid
        }
        headers = {
          
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        print(response.text)
        assert_that(response.status_code).is_equal_to(201)
        
    @pytest.fixture(scope="session")
    def test_create_company_set():
        url = MANAGE_URL+"/api/os/mxapisets"
        global csetid
        csetid="comset"+str(random.randint(5,100))

        querystring = {"lean":"1"}

        payload = {
            "settype_description": "Item Sets",
            "settype": "COMPANY",
            "setid": csetid
        }
        headers = {
          
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        print(response.text)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        
    @pytest.fixture(scope="session")
    def test_create_org():
        url = MANAGE_URL+"/api/os/mxapiorganization"
        global siteid,orgid
        querystring = {"lean":["1","1"]}
        orgid="org"+str(random.randint(0,1000))
        print(orgid)
        
        payload = {
            "active": False,
            "dfltitemstatus_description": "Active",
            "orgid": orgid,
            "basecurrency1": currency,
            "companysetid": csetid,
            "organizationid": 7,
            "description": "MY ORG IN GUJARAT",
            "dfltitemstatus": "ACTIVE",
            "itemsetid": setid,
            "category": "NS"
        }
        headers = {
          
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        print(response.text)

    @pytest.fixture(scope="session")
    def test_createGlCompany():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (111)",
            "glorder": 0,
            "active": True,
            "compvalue": 111,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        print(response.text)

    @pytest.fixture(scope="session")
    def test_createGlCompany2():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (222)",
            "glorder": 1,
            "active": True,
            "compvalue": 222,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        print(response.text)

    @pytest.fixture(scope="session")
    def test_createGlCompany3():
        url = MANAGE_URL+"/api/os/MXAPIGLCOMP"

        querystring = {"lean":"1"}

        payload = {
            "comptext": "Automation GL (333)",
            "glorder": 2,
            "active": True,
            "compvalue": 333,
            "orgid": orgid
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)
        print(response.text)

    @pytest.fixture(scope="session")
    def test_createGlAccount():
        url = MANAGE_URL+"/api/os/MXAPICOA"

        querystring = {"lean":"1"}

        payload = {
            "glaccount": "111-222-333",
            "accountname": "111-222-333",
            "active": True,
            "glcomp01": "111",
            "glcomp02": "222",
            "glcomp03": "333",
            "orgid": orgid
        }
        headers = {
          
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)

        print(response.text)
        assert_that(response.status_code).is_equal_to(requests.codes.created)

    @pytest.fixture(scope="session")
    def test_updateOrgToActiveSiteAndGL():
        url = MANAGE_URL+"/api/os/mxapiorganization"
        global siteid
        orgid2= "orgid=\""+orgid+"\""
        print(orgid2)
        querystring = {"lean":["1","1"],"oslc.select":"*","oslc.where":orgid2}
        print(querystring)

        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }

        response = requests.request("GET", url, headers=headers, params=querystring)
        print("response")
        jsonresponse=response.json()

        print(jsonresponse['member'][0]['organizationid'])
        orgid3=jsonresponse['member'][0]['organizationid']

        url = MANAGE_URL+"/api/os/mxapiorganization/"+str(orgid3)
        siteid="site"+str(random.randint(0,100))
        print(siteid)
        querystring = {"lean":["1","1"]}

        payload = {
            "site": [
                {
                    "description_longdescription": "Automation Site 1",
                    "active": True,
                    "description": "Automation Site 1",
                    "siteid": siteid
                }
            ],
            "clearingacct": "111-222-333",
            "active": True
        }
        headers = {
        
            "Content-Type": "application/json",
            "x-method-override": "PATCH",
            "patchtype": "MERGE",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(204)

    @pytest.fixture(scope="session")
    def test_create_user():
        url = MANAGE_URL+"/api/os/mxapiperuser"
        querystring = {"lean":"1"}
        personid="person"+str(random.randint(0,100))
        payload = {
            "personid": personid,
            "firstname": "first"+str(random.randint(0,100)),
            "lastname": "last"+str(random.randint(0,100)),
            "primaryemail": personid+"@yahoo.com",
            "primaryphone": "999 999 9999",
            "city": "Boston",
            "addressline1": "crazy road",
            "stateprovince": "MA",
            "postalcode": "01111",
            "country": "US",
            "language": "EN",
            "maxuser": [
                {
                    "loginid": personid,
                    "passwordcheck": personid,
                    "passwordinput": personid,
                    "defsite": "BEDFORD",
                    "type": "TYPE 1",
                    "userid": personid
                }
            ]
        }
        headers = {
            "Content-Type": "application/json",
            "apikey": apikey
        }
        response = requests.request("POST", url, json=payload, headers=headers, params=querystring)
        assert_that(response.status_code).is_equal_to(requests.codes.created)

---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $job_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "604"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  template:
    metadata:
      labels:
        app: {{ $job_name }}
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 8 }}
{{- end }}
    spec:
      imagePullSecrets: []
      containers:
        - name: run
          image: quay.io/ibmmas/cli:latest
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 200m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 64Mi
          env:
            - name: MAS_INSTANCE_ID
              value: "{{ .Values.instance_id }}"
            - name: MAS_WORKSPACE_ID
              value: "{{ .Values.mas_workspace_id }}"
          volumeMounts:
            - name: tests
              mountPath: /tmp/tests
          command:
            - /bin/sh
            - -c
            - |
              pip install -r /tmp/tests/requirements.txt
              pytest -o cache_dir=/tmp/__pycache__ /tmp/tests/tests.py 
      restartPolicy: Never
      serviceAccountName: {{ $sa_name }}
      volumes:
        - name: tests
          configMap:
            name: {{ $tests_cm_name }}
            items:
              - key: requirements.txt
                path: requirements.txt
              - key: tests.py
                path: tests.py
            defaultMode: 420
            optional: false
  backoffLimit: 4

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $record_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "605"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
  labels:
    type: mas-app-verification-record
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  mas_app: "manage"
  mas_catalog_version: "{{ .Values.mas_catalog_version }}"

{{- end }}
