{{- if eq .Values.mas_app_id "manage" }}

{{- /*
Use the build/bin/set-cli-image-digest.sh script to update this value across all charts.
*/}}
{{- $_cli_image_digest := "sha256:b3ecce096368c967bbc6bac2f074473a65418462417b6e550ad4777427c3b06b" }}

# A verify test is one that is non disruptive i.e. it won't create new users, i won't call authenticated apis, and it won't creates resources 
# in the application. This type of test is run on every environment and allows a layer of verification of the app

{{ $ns               :=  .Values.mas_app_namespace }}
{{ $np_name          :=  "postsync-verify-manage-np" }}
{{ $role_name        :=  "postsync-verify-manage-role" }}
{{ $sa_name          :=  "postsync-verify-manage-sa" }}
{{ $rb_name          :=  "postsync-verify-manage-rb" }}
{{ $tests_cm_name    :=  "postsync-verify-tests-manage-cm" }}
{{ $record_cm_name   :=  "postsync-verify-tests-manage-record-cm" }}
{{ $job_name         :=  "postsync-verify-manage-job" }}



---
# Permit outbound communication by the Job pod
# (Needed to communicate with the K8S HTTP API, PyPI, manage Route)
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: {{ $np_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  podSelector:
    matchLabels:
      app: {{ $job_name }}
  egress:
    - {}
  policyTypes:
    - Egress


---
kind: ServiceAccount
apiVersion: v1
metadata:
  name: {{ $sa_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}



---
# -------------------------------------
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $role_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "600"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
rules:
  - verbs:
      - get
      - list
    apiGroups:
      - "apps.mas.ibm.com"
    resources:
      - manageworkspace
      - manageapp
      - manageworkspaces
      - manageapps
  - verbs:
      - get
    apiGroups:
      - "route.openshift.io"
    resources:
      - routes
  - verbs:
      - get
      - list
      - patch
    apiGroups:
      - ""
    resources:
      - configmaps
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: {{ $rb_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "601"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
subjects:
  - kind: ServiceAccount
    name: {{ $sa_name }}
    namespace: {{ $ns }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ $role_name }}
# -------------------------------------


---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $tests_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "602"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  requirements.txt: |-
    pytest
    kubernetes
    openshift
  tests.py: |-
    from kubernetes import client,config
    from kubernetes.client import Configuration
    from openshift.dynamic import DynamicClient
    import pytest
    import os
    import requests
    import certifi
    import tempfile
    import logging

    logger = logging.getLogger()
    mas_instance_id = os.getenv("MAS_INSTANCE_ID")
    if mas_instance_id is None:
      raise Exception(f"Required MAS_INSTANCE_ID environment variable is not set")

    # e.g. "masdev"
    mas_workspace_id = os.getenv("MAS_WORKSPACE_ID")
    if mas_workspace_id is None:
      raise Exception(f"Required MAS_WORKSPACE_ID environment variable is not set")

    aibroker_api_key = os.getenv("AIBROKERAPIKEY")
    manage_namespace = f"mas-{mas_instance_id}-manage"
    manage_route_name = f"{mas_instance_id}-manage-{mas_workspace_id}"

    @pytest.fixture(scope="session")
    def dyn_client():
      if "KUBERNETES_SERVICE_HOST" in os.environ:
        config.load_incluster_config()
        k8s_config = Configuration.get_default_copy()
        k8s_client = client.api_client.ApiClient(configuration=k8s_config)
      else:
        k8s_client = config.new_client_from_config()
      dyn_client = DynamicClient(k8s_client)
      yield dyn_client

    @pytest.fixture(scope="session")
    def v1_manageworkspace(dyn_client):
      yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageWorkspace')

    @pytest.fixture(scope="session")
    def v1_manageapp(dyn_client):
      yield dyn_client.resources.get(api_version='apps.mas.ibm.com/v1', kind='ManageApp')

    @pytest.fixture(scope="session")
    def mange_workspace_reconciled_version(mange_workspace_cr):
      try:
        yield mange_workspace_cr['status']['versions']['reconciled']
      except KeyError as e:
        assert False, f"Unable to determine ManageWorkspace reconciled version. Error details: {e}"

    @pytest.fixture(scope="session")
    def manage_version(mange_app_cr):
      try:
        yield mange_app_cr['status']['components']['manage']['version']
      except KeyError as e:
        assert False, f"Unable to determine ManageApp component version. Error details: {e}"

    @pytest.fixture(scope="session")
    def mange_workspace_cr(v1_manageworkspace):
      yield v1_manageworkspace.get(namespace=manage_namespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}, mas.ibm.com/workspaceId={mas_workspace_id}").items[0]

    @pytest.fixture(scope="session")
    def mange_app_cr(v1_manageapp):
      yield v1_manageapp.get(namespace=manage_namespace, label_selector=f"mas.ibm.com/instanceId={mas_instance_id}").items[0]

    @pytest.fixture(scope="session")
    def v1_routes(dyn_client):
        yield dyn_client.resources.get(api_version='route.openshift.io/v1', kind='Route')

    @pytest.fixture(scope="session")
    def manage_route(v1_routes):
        yield v1_routes.get(name=manage_route_name, namespace=manage_namespace)

    @pytest.fixture(scope="session")
    def manage_host(manage_route):
      try:
        yield manage_route['spec']['host']
      except KeyError as e:
        assert False, f"Unable to determine manage host; spec.host key not present in {manage_route_name}/{manage_namespace}: {manage_route}. Error details: {e}"

    @pytest.fixture(scope="session")
    def manage_host_ca_filepath(manage_route):

      # Read the certificate field from the Manage Route. 
      # This may include CA certificates that we need in order to trust the certificates presented by the external Manage endpoint.
      try:
        manage_route_certificate = manage_route['spec']['tls']['certificate']
      except KeyError as e:
        pass

      # Read the caCertificate field from the Manage Route. 
      # This may include CA certificates that we need in order to trust the certificates presented by the external Manage endpoint.
      try:
        manage_route_caCertificate = manage_route['spec']['tls']['caCertificate']
      except KeyError as e:
        pass

      # Read the destinationCACertificate field from the Manage Route. 
      # This may include CA certificates that we need in order to trust the certificates presented by the internal Manage services.
      try:
        manage_route_destinationCACertificate = manage_route['spec']['tls']['destinationCACertificate']
      except KeyError as e:
        pass

      # Load default CA bundle. This will include certs for well-known CAs. This ensures that we will
      # trust the certificates presented by the external Manage endpoints when MAS is configured to use
      # an external frontend like CIS.
      with open(certifi.where(), 'rb') as default_ca:
        default_ca_content = default_ca.read()

      # Combine all of the above into a single .pem file that we can use when issuing HTTP requests
      chain_file = tempfile.NamedTemporaryFile(delete=False)
      try:
        
        if manage_route_certificate:
          chain_file.write(manage_route_certificate.encode())
        
        if manage_route_caCertificate:
          chain_file.write(manage_route_caCertificate.encode())

        if manage_route_destinationCACertificate:
          chain_file.write(manage_route_destinationCACertificate.encode())

        chain_file.write(default_ca_content)
        print(chain_file)
        chain_file.flush()
        chain_file.close()

        yield chain_file.name

      finally:
        os.remove(chain_file.name)

    def test_expected_reconciled_version(mange_workspace_reconciled_version, manage_version):
      assert manage_version == mange_workspace_reconciled_version, f"Expected ManageWorkspace Reconciled version: {mange_workspace_reconciled_version} to match Manage Operator version: {manage_version}"

    def test_languages_set(mange_workspace_cr):
      status_langs = mange_workspace_cr['status']['settings']['languages']
      spec_langs = mange_workspace_cr['spec']['settings']['languages']
      if spec_langs is not None:
        assert status_langs == spec_langs, f"Expected languages set in the spec: {spec_langs} to be equal to the languages in the status: {status_langs}"

    def test_addons_enabled(mange_workspace_cr):
      for component in mange_workspace_cr['spec']['components']:
        print(f"check component {component[0]} in status")
        assert mange_workspace_cr['status']['components'][component[0]]["enabled"], f"Expected component {component} to be enabled in status"

    def test_bundle_sizes(mange_workspace_cr):
      spec_serverbundles = mange_workspace_cr['spec']['settings']['deployment']['serverBundles']
      status_serverbundles = mange_workspace_cr['status']['settings']['deployment']['serverBundles']
      spec_serverbundles = [item for item in spec_serverbundles if item['bundleType'] != 'foundation']
      status_serverbundles = [item for item in status_serverbundles if item['bundleType'] != 'foundation']

      if status_serverbundles is not None:
        assert spec_serverbundles == status_serverbundles, f"Expected serverbundles set in the spec: {spec_serverbundles} to be equal to the serverbundles in the status: {status_serverbundles}"

    def test_get_manage_ai_service_ping(manage_host,manage_host_ca_filepath):
        # if isVersionApplicable==False:
        #    pytest.skip("Skipping because version is below 9.1")

      logger.info("Host CA Filepath:")
      logger.info(manage_host_ca_filepath)

      if aibroker_api_key == False:
        pytest.skip("AI Broker API key not found.")

      #if manage_host:
      #    MANAGE_URL = f'https://{mas_instance_id}-{mas_workspace_id}.mas-{mas_instance_id}-manage.svc'
      #  f"{MANAGE_URL}/maximo/api/pingaiservice",

      try:
        resp = requests.get(
          f"https://{manage_host}/maximo/api/pingaiservice",
          headers={
          "Content-Type": "application/json"
          },
          verify=False
        )
        resp.raise_for_status()  # Raise an error for bad responses
      except requests.exceptions.RequestException as e:
          print("Error during requests to Maximo Ping AI service:", e)
          assert False, "Error calling  GET /maximo/api/pingaiservice. Error details: {e}"

      resp_json = resp.json()
      logger.info("ping to ai service ::")
      logger.info(resp.text)

      assert resp.status_code == 200, f"Expected status 200 from GET /maximo/api/pingaiservice, but got {resp.status_code}. Body: {resp_json}."

      try:
        assert resp_json['aiservicehealth'] == True, f"Expected healthy field from GET /maximo/api/pingaiservice to be true, but was {resp_json['aiservicehealth']}. Body: {resp_json}"
      except KeyError as e:
        assert False, f"Expected aiservicehealth key not found in response from GET /maximo/api/pingaiservice. Body: {resp_json}"

      try:
        assert resp_json['aiserviceapikey'] == True, f"Expected healthy field from GET /maximo/api/pingaiservice to be true, but was {resp_json['aiserviceapikey']}. Body: {resp_json}"
      except KeyError as e:
        assert False, f"Expected aiserviceapikey key not found in response from GET /maximo/api/pingaiservice. Body: {resp_json}"

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: {{ $record_cm_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "604"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
  labels:
    type: mas-app-verification-record
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
immutable: false
data:
  mas_app: "manage"
  mas_catalog_version: "{{ .Values.mas_catalog_version }}"
  test_passed: "unknown"


---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ $job_name }}
  namespace: {{ $ns }}
  annotations:
    argocd.argoproj.io/sync-wave: "605"
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
{{- if .Values.custom_labels }}
  labels:
{{ .Values.custom_labels | toYaml | indent 4 }}
{{- end }}
spec:
  template:
    metadata:
      labels:
        app: {{ $job_name }}
{{- if .Values.custom_labels }}
{{ .Values.custom_labels | toYaml | indent 8 }}
{{- end }}
    spec:
      imagePullSecrets: []
      containers:
        - name: run
          image: quay.io/ibmmas/cli@{{ $_cli_image_digest }}
          imagePullPolicy: IfNotPresent
          resources:
            limits:
              cpu: 200m
              memory: 512Mi
            requests:
              cpu: 10m
              memory: 64Mi
          env:
            - name: MAS_INSTANCE_ID
              value: "{{ .Values.instance_id }}"
            - name: MAS_WORKSPACE_ID
              value: "{{ .Values.mas_workspace_id }}"
            - name: TEST_RECORD_CM
              value: "{{ $record_cm_name }}"
{{- if and (hasKey .Values "global_secrets") (hasKey .Values.global_secrets "mxe.int.aibrokerapikey") }}
            - name: AIBROKERAPIKEY
              value: "True"
{{- end }}
          volumeMounts:
            - name: tests
              mountPath: /tmp/tests
          command:
            - /bin/sh
            - -c
            - |
              python -m venv .venv
              source .venv/bin/activate
              pip install -r /tmp/tests/requirements.txt

              set -o pipefail
              echo "Running tests..."
              pytest -v --junit-xml=junitxml_test_output.xml -o cache_dir=/tmp/__pycache__ /tmp/tests/tests.py 2>&1 | tee test_log.txt
              if [[ $? -ne 0 ]]; then
                  TEST_PASSED=false
              else
                  TEST_PASSED=true
              fi
              echo "Test Result Passed: $TEST_PASSED"
              set +o pipefail

              set -e
              echo "Updating $TEST_RECORD_CM configmap with test result"
              oc set data cm $TEST_RECORD_CM test_passed=$TEST_PASSED
              oc set data cm $TEST_RECORD_CM --from-file=junitxml_test_output.xml
              oc set data cm $TEST_RECORD_CM --from-file=test_log.txt

              if [[ $TEST_PASSED == "false" ]]; then
                echo "Test Result failed, exit 1"
                exit 1
              fi
      restartPolicy: Never
      serviceAccountName: {{ $sa_name }}
      volumes:
        - name: tests
          configMap:
            name: {{ $tests_cm_name }}
            items:
              - key: requirements.txt
                path: requirements.txt
              - key: tests.py
                path: tests.py
            defaultMode: 420
            optional: false
  backoffLimit: 4


{{- end }}
